<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


  <meta name="google-site-verification" content="Dd1Gsd473q8nk0HCu8DB8QFSlsWc2fNWJIaRuZMwMUQ" />





  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.2"/>




  <meta name="keywords" content="Hexo,next,ivanz" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.2" />



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?2cace313a881340a6ccc899ac3fcf4b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <title> Ivan.Z </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Ivan.Z</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首頁
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分類
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          關於
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          歸檔
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          標籤
        </a>
      </li>
    
      
      <li class="menu-item menu-item-commonweal">
        <a href="/404.html">
          <i class="menu-item-icon icon-commonweal"></i> <br />
          公益404
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/06/27/根据名字创造地图/">
                根据名字创造地图
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-06-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/NMap/">NMap</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/06/27/根据名字创造地图/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/27/根据名字创造地图/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="根据你的名字生成一张随机地图">根据你的名字生成一张随机地图</h2><pre><code>
<script type="text/javascript" src="https://ssl-webplayer.unity3d.com/download_webplayer-3.x/3.0/uo/jquery.min.js"></script>
        <script type="text/javascript">
        <!--
        var unityObjectUrl = "http://webplayer.unity3d.com/download_webplayer-3.x/3.0/uo/UnityObject2.js";
        if (document.location.protocol == 'https:')
            unityObjectUrl = unityObjectUrl.replace("http://", "https://ssl-");
        document.write('<script type="text\/javascript" src="' + unityObjectUrl + '"><\/script>');
        -->
        </script>
        <script type="text/javascript">
        <!--
            var config = {
                width: 650, 
                height: 500,
                params: { enableDebugging:"0" }

            };
            config.params["disableContextMenu"] = true;
            var u = new UnityObject2(config);

            jQuery(function() {

                var $missingScreen = jQuery("#unityPlayer").find(".missing");
                var $brokenScreen = jQuery("#unityPlayer").find(".broken");
                $missingScreen.hide();
                $brokenScreen.hide();

                u.observeProgress(function (progress) {
                    switch(progress.pluginStatus) {
                        case "broken":
                            $brokenScreen.find("a").click(function (e) {
                                e.stopPropagation();
                                e.preventDefault();
                                u.installPlugin();
                                return false;
                            });
                            $brokenScreen.show();
                        break;
                        case "missing":
                            $missingScreen.find("a").click(function (e) {
                                e.stopPropagation();
                                e.preventDefault();
                                u.installPlugin();
                                return false;
                            });
                            $missingScreen.show();
                        break;
                        case "installed":
                            $missingScreen.remove();
                        break;
                        case "first":
                        break;
                    }
                });
                u.initPlugin(jQuery("#unityPlayer")[0], "/2015/06/27/根据名字创造地图/webplayer.unity3d");
            });
        -->
        </script>
        <style type="text/css">
        <!--
        body {
            font-family: Helvetica, Verdana, Arial, sans-serif;
            background-color: white;
            color: black;
            text-align: center;
        }
        a:link, a:visited {
            color: #000;
        }
        a:active, a:hover {
            color: #666;
        }
        p.header {
            font-size: small;
        }
        p.header span {
            font-weight: bold;
        }
        p.footer {
            font-size: x-small;
        }
        div.content {
            margin: auto;
            width: 650px;
        }
        div.broken,
        div.missing {
            margin: auto;
            position: relative;
            top: 50%;
            width: 193px;
        }
        div.broken a,
        div.missing a {
            height: 63px;
            position: relative;
            top: -31px;
        }
        div.broken img,
        div.missing img {
            border-width: 0px;
        }
        div.broken {
            display: none;
        }
        div#unityPlayer {
            cursor: default;
            height: 500px;
            width: 650px;
        }
        -->
        </style>
<div class="content">
    <div id="unityPlayer">
        <div class="missing">
            <a href="http://unity3d.com/webplayer/" title="Unity Web Player. Install now!" target="_blank" rel="external">
                <img alt="Unity Web Player. Install now!" src="http://webplayer.unity3d.com/installation/getunity.png" width="193" height="63">
            </a>
        </div>
    </div>
</div>

</code></pre>
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NMap/"> #NMap </a>
          
            <a href="/tags/Unity3D/"> #Unity3D </a>
          
            <a href="/tags/地图/"> #地图 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/06/24/为游戏生成多边形地图-3-3/">
                （原创）为Unity3D游戏生成2D和3D多边形随机地图(3/3)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-06-24
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/翻译/">翻译</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/06/24/为游戏生成多边形地图-3-3/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/24/为游戏生成多边形地图-3-3/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="NMap的诞生">NMap的诞生</h2><p>博主fork了一个开源的unity实现版本，发现这是个未完工的项目，只是实现了基础的架构。<br>于是准备在这个基础上打造一个更全面的地图生成插件nmap，免费共享出来。希望最终打造成一个可以按照用户的需求完全随机生成2D或者3D地图。<br>由于工作繁忙，现在只是在原来的基础上添加了一个tutorial场景，添加了对应文章章节的代码渲染输出。方便大家对照学习这篇文章。</p>
<p>nmap的github地址是：<a href="https://github.com/losetear/nmap" target="_blank" rel="external">https://github.com/losetear/nmap</a></p>
<p>webgl版本：TODO</p>
<p>下面贴一组对照章节的示意图，大家可以查看一个完整的地图是如何生成的。</p>
<h3 id="生成多边形">生成多边形</h3><img src="/2015/06/24/为游戏生成多边形地图-3-3/1.png" alt="1.png" title="">
<h3 id="均匀分布">均匀分布</h3><img src="/2015/06/24/为游戏生成多边形地图-3-3/2.png" alt="2.png" title="">
<h3 id="双图形显示">双图形显示</h3><img src="/2015/06/24/为游戏生成多边形地图-3-3/3.png" alt="3.png" title="">
<h3 id="识别陆地">识别陆地</h3><img src="/2015/06/24/为游戏生成多边形地图-3-3/4.png" alt="4.png" title="">
<h3 id="渲染海拔图">渲染海拔图</h3><img src="/2015/06/24/为游戏生成多边形地图-3-3/5.png" alt="5.png" title="">
<h3 id="生成河流">生成河流</h3><img src="/2015/06/24/为游戏生成多边形地图-3-3/6.png" alt="6.png" title="">
<h3 id="显示湿度图">显示湿度图</h3><img src="/2015/06/24/为游戏生成多边形地图-3-3/7.png" alt="7.png" title="">
<h3 id="显示生物圈">显示生物圈</h3><img src="/2015/06/24/为游戏生成多边形地图-3-3/8.png" alt="8.png" title="">
<h3 id="显示最终效果图">显示最终效果图</h3><img src="/2015/06/24/为游戏生成多边形地图-3-3/9.png" alt="9.png" title="">
        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NMap/"> #NMap </a>
          
            <a href="/tags/Unity3D/"> #Unity3D </a>
          
            <a href="/tags/地图/"> #地图 </a>
          
            <a href="/tags/随机/"> #随机 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/06/11/为游戏生成多边形地图-2-3/">
                （原创）为Unity3D游戏生成2D和3D多边形随机地图(2/3)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-06-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/翻译/">翻译</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/06/11/为游戏生成多边形地图-2-3/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/11/为游戏生成多边形地图-2-3/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <blockquote><p>原版Demo，稍后会放出改进版的Unity版本</p>
<footer><strong>Ivan.Z</strong><cite><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/demo.html" target="_blank" rel="external">官方Demo</a></cite></footer></blockquote>
<h2 id="Rivers_河流">Rivers 河流</h2><p>Rivers and lakes are the two fresh water features I wanted. The most realistic approach would be to define moisture with wind, clouds, humidity, and rainfall, and then define the rivers and lakes based on where it rains. Instead, I’m starting with the goal, which is good rivers, and working backwards from there.<br>我想要地图里包含河流和湖泊。最通用的办法是先定义一个包含风，云，湿度和降雨的湿度图，然后在这个基础上定义河流和湖泊。相反，我先设定好地图上的河流，然后从这里倒退计算。</p>
<p>The island shape determines which areas are water and which are land. Lakes are water polygons that aren’t oceans.<br>岛屿的形状决定了哪些区域是水哪些是陆地。标记为水的多边形除了海洋就是湖泊。</p>
<p>Rivers use the downhill directions shown earlier. I choose random corner locations in the mountains, and then follow the Corner.downslope path down to the ocean. The rivers flow from corner to corner:<br>如前所示，河流使用了下坡的方向。我选择山峰的一个随机角落，然后按照Corner.downslope方向一路走向海洋。河流从一个角落流向另一个角落：<br><img src="/2015/06/11/为游戏生成多边形地图-2-3/river.png" alt="river.png" title=""></p>
<p>I tried both polygon centers and corners, but found that the corner graph made for much nicer looking rivers. Also, by keeping lakes flat, elevation tends to be lower near lakes, so rivers naturally flow into and out of lakes. Multiple rivers can share the lower portion of their path. Every time a river flows through an edge, I increase the water volume stored in Edge.river by 1. At rendering time, the river width is the square root of the volume. This approach is simple and works well.<br>我分别尝试过使用多边形的中心和角落来计算河流，最后发现还是角落的图集生成的河流更好看。此外，通过保持湖泊的平坦，靠近湖泊的海拔自然趋向更低，所以河流很自然的流入和流出湖泊。多个河流可以共享它们的部分下游路径。每当一条河流经过一条边缘，我就会将存储在Edge.river 变量里的水量加1。这样在渲染的时候，河流的宽度就是水量的平方了。这种方既简单效果又好。</p>
<h2 id="Moisture_湿度图">Moisture 湿度图</h2><p>Since I’m working backwards, I don’t need moisture to form rivers. However, moisture would be useful for defining biomes (deserts, swamps, forests, etc.). Since rivers and lakes should form in areas with high moisture, I defined moisture to decrease as distance from fresh water increases. Corner.moisture is set to a^k for some a &lt; 1 (e.g. 0.95), and k being the distance. There are unfortunately some tuning parameters in Map.assignCornerMoisture that I tweaked until the maps looked reasonable:<br>由于我是逆向工作的，所以不需要一个湿度图来生成河流。然而，湿度图对于定义生物群落 还是很有用的（比如沙漠，沼泽，森林等）。由于河流和湖泊要从高湿度的区域发起，我定义湿度的规则为随着远离淡水则降低水分 。Corner.moisture被设定为a^k（a的k次方），注意a永远&lt;1 （例如0.95），并且k作为远离淡水的距离。不幸的是我需要手动调整Map.assignCornerMoisture 参数，直到地图看起来合理为止。</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/moisture.png" alt="moisture.png" title="">
<p>As with elevation, I redistribute moisture to match a desired distribution. In this case, I want roughly equal numbers of dry and wet regions. The desired cumulative distribution is y(x) = x, so the redistribution code is very simple. I sort by moisture and then assign the moisture of each corner to that corner’s position in the sorted list. See Map.redistributeMoisture for the code.<br>和海拔一样，我重新分配了湿度直到符合期望的分布。在这种情况下，我希望干旱和湿润地区大致相等。所需的累积分布函数是y(x) = x ，所以分配代码是很简单的。我先按照湿度排序角落，然后按照每个角落在排序里的顺序分配湿度。查看代码里的Map.redistributeMoisture一值。</p>
<p>In this map generator, moisture is only used for biomes. However, games may find other uses for the moisture data. For example, Realm of the Mad God uses moisture and elevation to distribute vegetation and monsters.<br>在这个地图生成器里，湿度只用来处理生物群落。然而，游戏可能会将之用在其他的地方。例如，  Realm of the Mad God采用水分和海拔来分布植被和怪物。</p>
<h2 id="Biomes_生物群落">Biomes 生物群落</h2><p>Together, elevation and moisture provide a good amount of variety to define biome types. I use elevation as a proxy for temperature. If this were a continent generator, latitude might be a contributor to temperature. Also, wind, evaporation, and rain shadows might be useful for transporting moisture as humidity. However, for this generator I kept it simple. Biomes first depend on whether it’s water or land:<br>总之，海拔和湿度提供了足够的多样性来定义生物类型。我使用海拔来代理温度。如果这是一个大陆生成器，纬度可能是影响温度的主要贡献者。此外，风，水分蒸发和雨影区也会导致湿度的转移。不过，我保持了这个算法的简洁。生物群落首先依赖于地形是水面还是陆地。</p>
<ul>
<li>OCEAN is any water polygon connected to the map border</li>
<li>LAKE is any water polygon not connected to the map border, or ICE lake if the lake is at high elevation (low temperature), or MARSH if it’s at low elevation </li>
<li>BEACH is any land polygon next to an ocean</li>
<li>OCEAN是任何接触到地图边缘的水多边形。</li>
<li>湖泊是任何没有连接到地图边界的水多边形，或者冰湖则是高海拔且低温度的湖泊，沼泽 则是低海拔的湖泊。</li>
<li>海滩则是毗邻海洋的土地多边形</li>
</ul>
<p>For all land polygons, I started with the Whittaker diagram and adapted it to my needs:<br>对于所有的土地多边形，我开始用Whittaker diagram算法来处理，并将之修改为适应我的需求：</p>
<p>Elevation Zone                    Moisture Zone</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:right">6(wet)</th>
<th style="text-align:right">5</th>
<th style="text-align:right">4</th>
<th style="text-align:right">3</th>
<th style="text-align:right">2</th>
<th style="text-align:right">1(dry)</th>
</tr>
</thead>
<tbody>
<tr>
<td>4(high)</td>
<td style="text-align:right">SNOW</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">TUNDRA</td>
<td style="text-align:right">BARE</td>
<td style="text-align:right">SCORCHED</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:right">TAIGA</td>
<td style="text-align:right"></td>
<td style="text-align:right">SHRUBLAND</td>
<td style="text-align:right"></td>
<td style="text-align:right">TEMPERATE DESERT</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>2</td>
<td style="text-align:right">TEMPERATE RAIN FOREST</td>
<td style="text-align:right">TEMPERATE DECIDUOUS FOREST</td>
<td style="text-align:right"></td>
<td style="text-align:right">GRASSLAND</td>
<td style="text-align:right"></td>
<td style="text-align:right">TEMPERATE DESERT</td>
</tr>
<tr>
<td>1(low)</td>
<td style="text-align:right">TROPICAL RAIN FOREST</td>
<td style="text-align:right"></td>
<td style="text-align:right">TROPICAL SEASONAL FOREST</td>
<td style="text-align:right"></td>
<td style="text-align:right">GRASSLAND</td>
<td style="text-align:right">SUBTROPICAL DESERT</td>
</tr>
</tbody>
</table>
<p>海拔区                    湿度区</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:right">6(湿)</th>
<th style="text-align:right">5</th>
<th style="text-align:right">4</th>
<th style="text-align:right">3</th>
<th style="text-align:right">2</th>
<th style="text-align:right">1（干）</th>
</tr>
</thead>
<tbody>
<tr>
<td>4(高)</td>
<td style="text-align:right">雪地</td>
<td style="text-align:right"></td>
<td style="text-align:right"></td>
<td style="text-align:right">冻土</td>
<td style="text-align:right">荒原</td>
<td style="text-align:right">焦土</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:right">针叶林</td>
<td style="text-align:right"></td>
<td style="text-align:right">灌木丛</td>
<td style="text-align:right"></td>
<td style="text-align:right">温带荒漠</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>2</td>
<td style="text-align:right">温带雨林</td>
<td style="text-align:right">温带落叶林</td>
<td style="text-align:right"></td>
<td style="text-align:right">草原</td>
<td style="text-align:right"></td>
<td style="text-align:right">温带荒漠</td>
</tr>
<tr>
<td>1(低)</td>
<td style="text-align:right">热带雨林</td>
<td style="text-align:right"></td>
<td style="text-align:right">热带季雨林</td>
<td style="text-align:right"></td>
<td style="text-align:right">草原</td>
<td style="text-align:right">亚热带沙漠</td>
</tr>
</tbody>
</table>
<p>Here’s the result:<br>这里是结果：</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/biomes.png" alt="biomes.png" title="">
<p>These biomes look good in the map generation demo, but each game will have its own needs. Realm of the Mad God for example ignores these biomes and uses its own (based on elevation and moisture).<br>这些生物群落在这个地图生成器demo里看起来不错，但每个游戏都会有自己独特的需求。以 Realm of the Mad God为例，它忽略了这些生物群落，并使用它自己的算法（基于海拔和湿度）。</p>
<h2 id="Noisy_Edges_噪声化边缘">Noisy Edges 噪声化边缘</h2><p>For some games, the polygonal maps are sufficient. However, in other games I want to hide the polygon structure. The main way I do that is to replace the polygon borders with a noisy line. Why would I want a polygon structure if I’m just going to hide it? I think game mechanics and pathfinding benefit from the underlying structure.<br>对于一些游戏，多边形地图就足够了。但是，在其他游​​戏里我想要隐藏多边形结构。我所用的方法是用扰乱的线条来替换多边形边界。如果我想要隐藏它为什么我还想要多边形结构。那是因为我认为游戏机制和寻路将会受益于这个底层结构。</p>
<p>Recall from earlier that there are two graphs: one for Voronoi corners (1, 2 in the diagram below) and edges (blue lines), and one for polycon centers (A, B) and Delaunay edges (red lines) between them:<br>回想一下开始的时候，我们有两个图形：一个用于Voronoi 拐角（ 下图中的1 ， 2）和边缘（蓝线），还有一个用于多边形中心（ A ， B ），和他们之间的Delaunay 边缘（红色线）：</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/edge-duality.png" alt="edge-duality.png" title="">
<p>I wanted to make both types of line noisy without making them cross lines from other polygons. I also wanted to make them as noisy as feasible. I realized that points A, 1, B, and 2 form a quadrilateral, and I could constrain the wanderings of the line segment to that quadrilateral:<br>我想扰乱这两种类型的边缘，但又不想让他们再次相交。并且需要确保他们是可以被扰乱的。我意识到点A ， 1 ， B ，和2形成了一个四边形，我可以将扰乱后的线条片段约束在这个四边形内：</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/edge-noisiness.png" alt="edge-noisiness.png" title="">
<p>I further divided the quadrilateral into four quadrilaterals. Two were usable for the red (Delaunay) edge and two for the blue (Voronoi) edge. As long as the lines stayed within their allocated space and met in the center, they’d never cross each other. That takes care of constraining them. Note that the quadrilateral may not be convex; to divide it properly, I divide it at the midpoint of the Voronoi edge instead of at the intersection of the Voronoi and Delaunay edges.<br>我进一步将四边形分成四个四边形。两个用于红色（Delaunay）的边缘，还有两个用于蓝色（Voronoi）边。只要这些线段待在分配给他们的空间里，并且只在中心相交，那他们就永远不会互相相交。这需要谨慎制约他们。需要注意的是四边形未必是凸多边形;为了正确地将其划分，我从Voronoi 边的中点开始拆分而不是在Voronoi 和Delaunay 边的交叉点。</p>
<p>The entire map can be divided up into these quadrilateral regions, with no space left over:<br>整个地图可以全部被划分成四边形区域，无一遗漏：</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/quad-markings.png" alt="quad-markings.png" title="">
<p>That ensures that the noisy lines aren’t constrained any more than necessary. (I wonder if these quadrilaterals would be useful for game mechanics.)<br>这保证了扰乱线段除了必须的限制不会有更多要求了。（我不知道这些四边形对于游戏机制是否有用。）</p>
<p>I can use any noisy line algorithm that fits within these constraints. I decided to subdivide the quadrilaterals recursively and stitch line segments together within the small quadrilaterals into a complete edge. The algorithm is in NoisyEdges.as, in buildNoisyLineSegments. The result is that the polygon edges are no longer straight:<br>我可以使用任何噪声算法，只要保证它们在约束内即可。我决定递归细分四边形和并将小四边形内的线段连成一个完整的边缘。该算法代码包含在NoisyEdges.as 的buildNoisyLineSegments 函数里。最终的结果是多边形的边缘不再笔直。</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/biomes-noisy.png" alt="biomes-noisy.png" title="">
<p>There are three places to tune the noisiness:<br>有三个地方需要调整设置：</p>
<ol>
<li>The recursive function ends when the segments are shorter than some length. I have examples at segment size 7, segment size 4, and segment size 1. In the map demo I use segment size 1 for rivers and coastlines, 3 where biomes meet, and 10 elsewhere.</li>
<li>当片段小于预定的值时，递归函数将会结束。这里有一些例子，分别是片段大小为7 ， 片段大小为4 ，和片段大小为1 。在地图的demo里，我将河流和海岸线的片段值设为1，生物群落的片段值设为3，剩下的都设为10。</li>
<li>There’s a tradeoff between how much of the space goes to the red quadrilaterals (Delaunay edges) and blue quadrilaterals (Voronoi edges). I set NoisyEdges.NOISY_LINE_TRADEOFF to 0.5.</li>
<li>还需要权衡有多少空间属于红色四边形（Delaunay边）和蓝色四边形（Voronoi边）。我将 NoisyEdges.NOISY_LINE_TRADEOFF设置为0.5。</li>
<li>There’s a range of random numbers in NoisyEdges.subdivide. In the current demo it’s from 0.2-0.8, but it can be up to 0.0–1.0. Also, the random numbers don’t have to be linearly chosen. More visual noise results if you avoid the space around 0.5.</li>
<li>在NoisyEdges.subdivide 函数里有一个随机数范围。在当前的demo里是从0.2-0.8，但它可以设置为0.0-1.0。另外，随机数不必按照线性选择。如果您避免在空间被平均划分，就会获得更加噪声化的视觉结果。</li>
</ol>
<p>Noisy edges turn out to have a large impact on the map appearance, especially for rivers and coastlines.<br>噪声化后的边缘对地图的外观有很大的影响，特别是对河流和海岸线。</p>
<h2 id="More_noise_更多的噪声">More noise 更多的噪声</h2><p>I’m generally a fan of noise in game art, and wanted to add a little bit of noise to these maps as well. In a real game map the noise might reflect vegetation or small variations in terrain. In the demo (mapgen2.as) I just filled the screen with a random noise texture by adding a noise bitmap on top. I also smoothed the borders between adjacent polygons by blending the colors in stages:<br>通常我都是推崇在游戏美术里添加噪声 ，但希望只添加一点点噪声到这些地图为好。在一个真正的游戏地图中,噪声可以用于反映植被或地形的微小变化。在演示（ mapgen2.as ）里，我只是用一个随机噪声贴图来填充屏幕。我还通过混合相邻多边形边缘的颜色来平滑边界。</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/voronoi-map-goal.png" alt="voronoi-map-goal.png" title="">
<p>Here’s a rendering with 16,000 polygons, noisy edges, a noise texture overlay, and simple lighting:<br>这个渲染示例拥有16000个多边形，并噪声化边缘，噪声纹理覆盖，以及简单的灯光：</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/voronoi-map-goal-16000-shaded.png" alt="voronoi-map-goal-16000-shaded.png" title="">
<h2 id="Smooth_biome_transitions_平滑生物群落的过度">Smooth biome transitions 平滑生物群落的过度</h2><p>A different way of blending the biomes at polygon boundaries is to build gradients using the elevation and moisture at each corner, and then assigning biomes per pixel:<br>还有一种混合多边形边界的生物群落的方式，就是使用海拔和湿度在各个角落创建一个渐变 ，然后分配给每个像素分配生物群落值。</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/voronoi-map-goal-smooth.png" alt="voronoi-map-goal-smooth.png" title="">
<p>If the game doesn’t need an entire polygon to be the same biome, this approach can be useful for making more interesting boundaries.<br>如果游戏不需要整个多边形都是相同的生物群落，那这种方法可用于制造更有趣的边界。</p>
<h2 id="Distorted_biome_transitions_扭曲生物群落的过度">Distorted biome transitions 扭曲生物群落的过度</h2><p>Another way to make the map look less polygon-like is to distort the elevation and moisture maps:<br>还有一种使地图看起来不像多边形的方式就是扭曲海拔和湿度图。</p>
<ol>
<li>Add Perlin or random noise to the elevation and moisture at each pixel.</li>
<li>Sample nearby points using Perlin or random noise to change the coordinate.</li>
<li>添加Perlin或随机噪声函数到海拔和湿度图的每个像素。</li>
<li>使用培林或随机噪声函数在坐标附近采样</li>
</ol>
<p>Here’s an example of what this can do:<br>下面这个示例展示了可以做到什么效果：</p>
<img src="/2015/06/11/为游戏生成多边形地图-2-3/voronoi-map-goal-distorted.png" alt="voronoi-map-goal-distorted.png" title="">
<p>Adding noise to the elevation and moisture will produce “dithering” in the zones near transitions. Sampling nearby points using noise will distort the shapes of the boundaries.<br>将噪声添加到海拔和湿度图会导致在区域过度附近产生“抖动”。使用噪声在坐标附近采样会扭曲形状的边缘。</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Unity3D/"> #Unity3D </a>
          
            <a href="/tags/地图/"> #地图 </a>
          
            <a href="/tags/随机/"> #随机 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/06/01/为游戏生成多边形地图-1-3/">
                （原创）为Unity3D游戏生成2D和3D多边形随机地图(1/3)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-06-01
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/翻译/">翻译</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/06/01/为游戏生成多边形地图-1-3/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/01/为游戏生成多边形地图-1-3/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <blockquote><p>这是一篇关于如何生成自定义随机地图的文章，可以生成2D或者3D数据，包含山峰、湖泊、河流、草地等，相对于噪声算法生成的随机地图，这篇文章提供的思路拥有更多的控制权，可以针对你的游戏策划案来做相应的调整。由于工作繁忙，所以将这片翻译拆成三部分来发，敬请谅解。后面会提供对应的u3d工程直接使用。<br>因能力有限，翻译不到位的地方请多多原谅。</p>
<footer><strong>Ivan.Z</strong><cite><a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/demo.html" target="_blank" rel="external">官方Demo</a></cite></footer></blockquote>
<h1 id="为游戏生成多边形地图">为游戏生成多边形地图</h1><p>4 Sep 2010<br>I wanted to generate interesting game maps that weren’t constrained to be realistic, and I wanted to try some techniques I hadn’t tried before. I usually make tile maps but instead used a different structure. What could I do with 1,000 polygons instead of 1,000,000 tiles? The distinct player-recognizable areas might be useful for gameplay: locations of towns, places to quest, territory to conquer or settle, landmarks, pathfinding waypoints, difficulty zones, etc. I generated maps with polygons, then rasterized them into tile maps that looked like this:<br>2010年9月4日<br>我想生成一些有趣的不被现实所束缚的游戏地图，并且想尝试一些新技术。我通常用不同的结构来创建tile map。我怎样才能只使用1000个多边形而不是1百万个tile？对于不同的玩家来说，可识别的游戏区域对可玩性更有帮助：城镇地区，任务地点，可征服或定居的领地，地标，寻路坐标，难度标示区域等。我生成了多边形地图，然后栅格化成tile map，参考下图：<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/voronoi-map-goal-16000-shaded.png" alt="voronoi-map-goal-16000-shaded.png" title=""></p>
<p>Most procedural map generators, including some of my own previous projects, use noise functions (midpoint displacement, fractal, diamond-square, perlin noise, etc.) to generate a height map. I did not do that here. Instead, I used a graph structure to model the things directed by gameplay constraints (elevation, roads, river flow, quest locations, monster types) and noise functions to model the variety not constrained by gameplay (coastline shape, river placement, tree placement).<br>大多数程序生成的地图，包括一些我以前的项目，都是使用噪声函数（midpoint displacement, fractal, diamond-square, perlin noise等）来生成一张高度图。在这里我并没有这样做。相反，我用图结构来建模一些被游戏玩法所限制的东西（海拔，道路，河流，任务地点，怪物种类）并用噪声函数将一些不被游戏所限制（比如海岸线形状，河流的位置，树的位置）的变量建模。</p>
<p>There were three main things I wanted for this project: good coastlines, mountains, and rivers. For the coastline, I wanted to make island maps that are surrounded by ocean, so that I don’t have to deal with people walking to the edge of the map. For the mountains, I started with something simple: mountains are whatever’s farthest from the coastline, so that you can always walk uphill to reach the top. For the rivers, I started with something simple: draw rivers from the coast to the mountains, so that you can always follow rivers down to the beach.<br>我为这个项目定了三个主要的目标：良好的海岸线，山脉，以及河流。对于海岸线，我想创建一个被海洋包围的岛屿地图，这样我就不用处理人物走到地图边缘的情况了。对于山峰，我开始用一些简单的处理：山不管什么情况下都是离海岸线最远的，这样你就可以永远沿着上坡到达顶峰。对于河流，同样简单处理：河流源于海岸终于山峰，这样你就可以始终遵循河流到海滩。</p>
<p>First, try the demo! (Flash) Read on to learn how it works, or get the source code. Here’s the overview of the process:<br>首先， 尝试Demo ！ （注意）请仔细阅读，了解它是如何工作的，或者获取并查看源代码 。下面是这个过程的描述：<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/overview.png" alt="overview.png" title=""></p>
<p>Every project will have its own gameplay constraints. For this project, the gameplay constraints were partially taken from Realm of the Mad God, a multiplayer RPG in which players start on the beach playing alone and then later join together on the mountaintop to fight bosses. Elevation directly corresponds to difficulty, and must monotonically increase, so that was a key constraint in the design. Elevation in Minecraft on the other hand isn’t constrained the same way, so the noise function they use works for that game. In multiplayer Age of Empires, the location of resources is constrained by the need to be somewhat balanced among the players; in Minecraft the distribution of resources is not constrained. When writing your own map generator, think about what which aspects of your map are set by the design and which can vary from map to map. Each of the ideas on this page can be used separately or together in your own map generator project.<br>每个项目都会有自己的游戏玩法限制。对于这个项目，玩法的约束部分取自Realm of the Mad God ，这是一个多人RPG，玩家一开始独自在海滩上玩耍，之后汇合其他玩家一起到山顶打Boss。海拔和难度是直接对应的，并且必须单调增加，所以这是游戏设计中的一个关键约束。海拔在Minecraft游戏拥有另一方面的约束，所以噪声函数在这个游戏里运作的很好。在多人帝国时代里，资源的位置是由需要约束为玩家之间有所平衡;在的Minecraft资源分配是不是限制。当你开始写自己的地图生成器的时候，需要考虑那些方面是跟随设计而定的，那些是跟随着地图变化的。此页面上的每个想法都可以单独或一起用在你的地图生成器里。</p>
<h2 id="Polygons">Polygons</h2><h2 id="多边形">多边形</h2><p>The first step is to generate some polygons. The simplest approach would be to use a hexagonal grid and perturb it a bit to make it look irregular. This works (and the techniques on this page will work if you use a perturbed grid), but I wanted something even less regular than that, so I picked random points and generated Voronoi polygons, which are used for lots of things, including maps. The Voronoi wiki is incomplete but has some useful background. I’m using nodename’s as3delaunay library, which has an implementation of Fortune’s Algorithm.<br>第一个步骤是生成一些多边形。最简单的方法是使用一个六边形网格，然后将之扰乱使它看起来不规则。此方法可行（如果你使用一个扰乱后的网格也可以配合本页的技术使用），但我想要一个更不规则的东西，所以我选择了随机点来生成的Voronoi多边形 ，它被用于很多事情 ，包括地图。该沃罗诺伊 维基页是不完整的，但包含了一些有用的背景知识。我使用一个as3delaunay 库 ，它实现了Fortune’s Algorithm算法 。</p>
<p>Here’s an example of random dots (red) and the polygons that result:<br>下面是随机点（红色）和由此产生的多边形的一个例子：<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/voronoi-polygons.png" alt="voronoi-polygons.png" title=""></p>
<p>The polygon shapes and sizes are a bit irregular. Random numbers are more “clumpy” than what people expect. I want something closer to semi-random “blue noise”, or quasirandomness, not random points. I approximate that by using a variant of Lloyd relaxation, which is a fairly simple tweak to the random point locations to make them more evenly distributed. Lloyd relaxation replaces each point by the centroid of the polygon. In my code I merely average the corners (see improveRandomPoints). Here’s the result after running approximate Lloyd relaxation twice:<br>多边形的形状和大小都有点不规则。随机数比人们预期的更加成“块状”分布。我想要它们变得更接近半随机的“蓝噪音”，或quasirandomness ，而不是全随机的点。我通过使用一种Lloyd relaxation的变种算法达到了近似的效果 ，它通过一个相当简单的调整，来使随机点的位置更加均匀地分布。Lloyd relaxation将每个点的坐标替换成多边形的质心。在我的代码，我只是平均了拐角的坐标（查看improveRandomPoints ）。下面是运行Lloyd relaxation放松两次之后的结果：<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/voronoi-2-lloyd.png" alt="voronoi-2-lloyd.png" title=""></p>
<p>Compare it to running once or fifty times. The more iterations, the more regular the polygons get. Running it twice gives me good results but every game will vary in its needs.<br>比较运行算法一次或50次的区别 。迭代越多，地图就会变得越来越规整。运行两次已经可以满足我们的需求，但每个游戏都会有自己不同的需求。</p>
<p>Polygon sizes are improved by moving polygon centers. The same approach works to improve edge lengths. Moving corners by averaging the nearby centers produces more uniform edge lengths, although it occasionally worsens the polygon sizes. In the code, see the improveCorners function. However, moving corners will lose the Voronoi diagram properties. Those properties aren’t used in this map generator, but keep this in mind if you want to use those properties in a game. You can either get better edge lengths or you can preserve the Voronoi distance properties.<br>多边形的大小通过移动多边形的中心来改善。同样的方法适用于更改边长。通过移动附近中心的角落来产生更多统一的边缘长度，虽然偶尔会增加多边形的大小。在代码中，查看improveCorners功能。然而，移动边角会丢失Voronoi图的属性。这些属性并未在本地图生成器中使用，请记住这点，以防但如果你想在游戏中使用这些属性，记住这一点。您可以选择得到更好的边长，或者保留Voronoi距离的特性。</p>
<p>Using Voronoi adds some complexity so if you want to start with something simpler, try a square or hexagonal grid (you can see this in the demo). The rest of the techniques in this article will work with a grid. Optionally, randomly perturb the vertices of the grid to make it a little more natural looking.<br>使用Voronoi增加了一些复杂度，所以如果你想尝试一些简单的东西，选择方形或六边形网格（你可以在Demo里看到）。本文剩下的技术讲述如何在网格下工作。可选，随机地扰乱网格的顶点，使其稍微更自然的。</p>
<h2 id="Map_Representation">Map Representation</h2><h2 id="呈现地图">呈现地图</h2><p>I’m representing the map as two related graphs: nodes and edges. The first graph has nodes for each polygon and edges between adjacent polygons. It represents the Delaunay triangulation, which is useful for anything involving adjacency (such as pathfinding). The second graph has nodes for each polygon corner and edges between corners. It contains the shapes of the Voronoi polygons. It’s useful for anything involving the shapes (such as rendering borders).<br>我用两个相关的图 ：节点和边 来表示地图。第一个图拥有每个多边形的节点和相邻多边形之间的边缘。它代表了Delaunay三角形 ，这是一个用于处理任何涉及邻接的数据（例如寻路）。第二个图包含了每个多边形角落的节点和角落之间的边缘。它包含了Voronoi多边形的形状。这对任何涉及形状的处理（如渲染边界）是有用的。</p>
<p>The two graphs are related. Every triangle in the Delaunay triangulation corresponds to a polygon corner in the Voronoi diagram. Every polygon in the Voronoi diagram corresponds to a corner of a Delaunay triangle. Every edge in the Delaunay graph corresponds to an edge in the Voronoi graph. You can see this in the following diagram:<br>这两个图是相互关联的。每个Delaunay三角里的三角形都对应于Voronoi图的多边形边缘。Voronoi图里的每个多边形都对应于Delaunay三角形的所有边。Delaunay图中的每个边缘都对应于Voronoi图中的一条边。你可以在下图中看到对应关系：<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/edge-duality.png" alt="edge-duality.png" title=""></p>
<p>Polygon A and B are adjacent to each other, so there is a (red) edge between A and B in the adjacency graph. For them to be adjacent there must be a polygon edge between them. The (blue) polygon edge connects corners 1 and 2 in the Voronoi shape graph. Every edge in the adjacency graph corresponds to exactly one edge in the shape graph.<br>多边形A和B彼此相邻，所以有一条边缘（红）在A和B之间。因为它们是相邻的，所以肯定有一条多边形边在二者之间。多边形边（蓝色）连接了Voronoi图中的拐角1和拐角2。邻接图的每条边都对应于形状图的边缘。</p>
<p>In the Delaunay triangulation, triangle A-B-C connects the three polygons, and can be represented by corner 2. Thus, corners in the Delaunay triangulation are polygons in the Voronoi diagram, and vice versa. Here’s a larger example showing the relationship, with Voronoi polygon centers in red and corners in blue, and the Voronoi edges in white and the Delaunay triangulation in black:<br>在Delaunay三角图里，三角形A - B - C连接三个多边形，同时这几个多边形可以用拐角2 表示。因此，在Delaunay三角里的拐角也可以表示Voronoi图里的多边形，反之亦然。这里用一个更大的例子来展示这种关系，Voronoi多边形的中心点用红色表示，拐角用蓝色显示，以及用白色表示Voronoi图的边缘和黑色表示Delaunay三角：<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/voronoi-and-delaunay.png" alt="voronoi-and-delaunay.png" title=""></p>
<p>This duality means that I can represent the two graphs together. There are several approaches for combining the data from the two graphs. In particular, edges can be shared. Each edge in a normal graph points to two nodes. Instead of representing two edges in the two graph separately, I made edges point to four nodes: two polygon centers and two corners. It turns out to be quite useful to connect the two graphs together.<br>这种双重性意味着我可以一起展示这两种图形。有好几种方法可以整合这两种图的数据。特别是 共享边缘 。正常图形里的每个边缘都用两个节点来表示。我用四个节点来表示一条边缘：2个多边形中心和两个角，从而取代两个图里分别独立的边，。结果证明了这是一种有效的连接两个图的方法。</p>
<p>With the combined representation, I can now use the Relationships Between Grid Parts sections of my article on grids. They’re not grids so I’m not assigning grid coordinates, but many of the algorithms that work on grids also work here, and the algorithms that work on graphs also work here (on either of the two graphs).<br>随着合并表示，现在我可以使用关于网格的文章里提到的网格之间的关系 。不过它们（译者：所用的两种图）不是网格，所以我不能使用网格坐标，但许多建立在网格上的算法还可以正常工作，建立在图上的算法也同样可以运行（在任意一个图里）。</p>
<p>In the code, the graph/ directory has three classes: Center, Corner, and Edge:</p>
<ul>
<li>Center.neighbors is a set of adjacent polygons</li>
<li>Center.borders is a set of bordering edges</li>
<li>Center.corners is a set of polygon corners</li>
<li>Edge.d0 and Edge.d1 are the polygons connected by the Delaunay edge</li>
<li>Edge.v0 and Edge.v1 are the corners connected by the Voronoi edge</li>
<li>Corner.touches is a set of polygons touching this corner</li>
<li>Corner.protrudes is a set of edges touching the corner</li>
<li>Corner.adjacent is a set of corners connected to this one</li>
</ul>
<p>在代码中， graph/目录下有三个类： Center ， Corner和Edge ：</p>
<ul>
<li>Center.neighbors是一组相邻的多边形</li>
<li>Center.borders是一组相接的边缘</li>
<li>Center.corners是一组多边形的拐角</li>
<li>Edge.d0和Edge.d1是由Delaunay边连接的多边形</li>
<li>Edge.v0和Edge.v1是由Voronoi边缘相连的角</li>
<li>Corner.touches是一组多边形所涉及的所有拐角</li>
<li>Corner.protrudes是一组边缘所相接的角落</li>
<li>Corner.adjacent是一组连接到自身的拐角</li>
</ul>
<h2 id="Islands">Islands</h2><h2 id="岛屿">岛屿</h2><p>The second step is to draw the coastline. I used a simple function to divide the world into land and water. There are many different ways to do this. You can plug in your own shapes (even if they come from pizza boxes), although that code is not included in the demo. The map generator works with any division of points, but it forces the outer layer of polygons to be ocean. Here’s an example that divides the world into land and water:<br>第二个步骤是绘制海岸线。我用一个简单的函数来把世界分割成海洋和陆地。有许多方法都可以做到这一点。你可以使用自己的形状来标记地图（就算使用披萨盒的形状都可以 ），不过演示不包含此代码。地图生成器可以任意划分点（应该是多边形吧），但它默认了多边形的最外边是海洋。下面是将一个将世界分为陆地和海洋的例子：<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/voronoi-land-water.png" alt="voronoi-land-water.png" title=""></p>
<p>In the code, Map.as contains the core map generation code. The IslandFunction returns True if a position is land, and False for water. There are four island functions included in the demo:</p>
<ul>
<li>Radial uses sine waves to produce a round island</li>
<li>Perlin uses Perlin noise to control the shape</li>
<li>Square fills the entire map with land</li>
<li>Blob draws my blob logo</li>
</ul>
<p>在代码中， Map.as包含了核心的地图生成代码。如果当前位置是陆地，则IslandFunction函数返回True ，否则False代表海水。Demo里包含了四种岛屿的形状函数：</p>
<ul>
<li>Radial采用正弦波算法产生一个圆形的岛屿</li>
<li>Perlin使用培林噪声算法控制形状</li>
<li>Square将整个地图标记为陆地</li>
<li>Blob绘制了我的博客logo</li>
</ul>
<p>The code assigns water/land to both polygon centers and corners:</p>
<ol>
<li>Assign water/land to the corners by setting Corner.water based on the IslandFunction.</li>
<li>Assign water/land to the polygons by setting Center.water if some fraction of the corners have water set.</li>
</ol>
<p>该代码同时识别了多边形中心和拐角的海洋陆/地属性：</p>
<ol>
<li>通过Island Function 函数来设置Corner.water属性，从而识别拐角是海洋还是陆地。</li>
<li>如果部分拐角有water集，则将多边形 的Center.water设置为海洋。</li>
</ol>
<p>A simple flood fill starting from the border of the map can determine which water areas are oceans (connected to the border) and lakes (surrounded by land):<br>一个简单的洪水填充从地图的边界开始，这样就可以确定哪些水域是海洋（连接到边缘）或湖泊（被陆地包围）：<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/voronoi-land-ocean-lake.png" alt="voronoi-land-ocean-lake.png" title=""></p>
<p>In the code, the flood fill runs on the polygon centers, and then we can decide what happens to corners:</p>
<ol>
<li>Set Center.ocean for any polygon connected to the borders of the map through water polygons. If Center.water is set but .ocean is not, then it’s a lake.</li>
<li>Set Center.coast if the polygon is land but has an ocean border. Coastal areas will later get drawn as beaches.</li>
<li>Set Corner.ocean if the corner is surrounded by ocean polygons.</li>
<li>Set Corner.coast if the corner touches ocean and land polygons.</li>
<li>Reset Corner.water to be consistent with the surrounding area.</li>
</ol>
<p>在代码中，洪水填补算法使用了多边形的中心，然后我们可以决定拐角是什么：</p>
<ol>
<li>将任何可以通过海水多边形连接到地图边界的多边形设置Center.ocean标记。如果Center.water被设置，但.ocean没有，那么它是一个湖泊。</li>
<li>如果多边形是陆地，但有一个海洋边界，则设置Center.coast。沿海地区稍后会当作海滩来绘制。</li>
<li>如果拐角被海洋多边形包围，则设置Corner.ocean。</li>
<li>如果拐角同时触及海洋和陆地多边形，则设置Corner.coast。</li>
<li>将Corner.water重置为和周边地区一致。</li>
</ol>
<h2 id="Elevation">Elevation</h2><h2 id="海拔">海拔</h2><p>The most realistic approach would have been to define elevation first, and then define the coastline to be where the elevation reaches sea level. Instead, I’m starting with the goal, which is a good coastline, and working backwards from there. I set elevation to be the distance from the coast. I originally tried elevations at polygon centers but setting elevations at corners worked out better. Corner-to-corner edges can serve as ridges and valleys. After calculating the elevation of corners (Corner.elevation), the polygon elevation (Center.elevation) is the average of the elevation at the corners. See the functions Map.assignCornerElevations and Map.assignPolygonElevations.<br>最常用的办法是先定义海拔图，然后将海拔达到海平面的地方定义为海岸线。相反，我从定义海岸线开始，然后倒退计算海拔。将海拔定义为离海岸的距离 。我本来试图将海拔设置在多边形的中心，但是发现设置在拐角处效果更好。角和角之间的边界线可以作为山谷。计算拐角的海拔（Corner.elevation ）后，多边形的海拔高度（ Center.elevation ）就可以从所有拐角的平均值获得。请参阅函数Map.assignCornerElevations和Map.assignPolygonElevations 。</p>
<p>Water polygons don’t count towards the distance. This is both because I expect lakes to be flat instead of sloped, and because this tends to build valleys around lakes, which helps guide rivers towards lakes.<br>被标记为水面的多边形不算入计算海拔的多边形里面。这既是因为我期望湖泊是平坦而不是倾斜的，还因为我们的山谷是围绕着湖泊的，这有助于将河流导向湖泊。<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/elevations.png" alt="elevations.png" title=""></p>
<p>One problem with the simple definition is that some islands have too many mountains and others have too few. To fix this, I redistribute the elevations to match a desired distribution, which has more low elevation land (coastline) than high elevation land (mountains). First, I sort the corners by elevation, and then I reset the elevation x of each to match the inverse of the desired cumulative distribution: y(x) = 1 - (1-x)^2. In the Map.redistributeElevations function, y is the position in the sorted list, and x is the desired elevation. Using the quadratic formula, I can solve for x. This preserves ordering so that elevations always increase from the coast to the mountains.<br>还有一个简单的问题，那就是一些岛屿拥有太多的山峰而其他的太少。为了解决这个问题，我将重新分配海拔来达到期望的分布，它将拥有更多的低海拔的土地（岸线）和少量的高海拔地（山）。首先，我通过海拔的高低来对拐角进行排序，然后我通过排序后海拔的索引x来达到期望的分布，新的海拔的值来自函数： y(x) = 1 - (1-x)^2 。在Map.redistributeElevations函数里， y是在排序列表中的位置，x是期望的海拔。使用二次方程式，我可以得到x 。通过保留排序，所以海拔总是从沿海到山峰增加。</p>
<p>For any location, going downhill will eventually lead to the ocean. This diagram shows the steepest downhill direction from every corner, stored in Corner.downslope:<br>对于任何位置，一直下坡都会到达海洋。此图显示了从每一个角落的下坡方向，存储在Corner.downslope ：<br><img src="/2015/06/01/为游戏生成多边形地图-1-3/downslopes.png" alt="downslopes.png" title=""></p>
<p>By following the downhill arrows from any location, we eventually reach the ocean. This will be useful for rivers but may also be useful for calculating watersheds and other features.<br>按照任何位置的下坡箭头，我们都能到达海洋。这对于计算河流很有用，但也可以用于计算分水岭和其它特征。</p>
<p>I had two main goals for elevation:</p>
<ol>
<li>Biome types: high elevations get snow, rock, tundra; medium elevations get shrubs, deserts, forests, and grassland; low elevations get rain forests, grassland, and beaches.</li>
<li>Rivers flow from high elevations down to the coast. Having elevations that always increase away from the coast means that there’s no local minima that complicate river generation.</li>
</ol>
<p>对于海拔，我有两个主要目标：</p>
<ol>
<li>生物群落类型：高海拔地区会下雪，岩石，苔原;中海拔获得灌木，沙漠，森林，草原，低海拔获得雨林，草原，和海滩。</li>
<li>河流从高处流到海岸。其海拔总是和海岸的距离相反，意味着不会有局部的小且复杂的河流产生。</li>
</ol>
<p>In addition, games may define their own use of elevation data. For example, Realm of the Mad God uses elevation to distribute monsters.<br>此外，游戏可以定义自己的海拔数据。例如， Realm of the Mad God利用海拔来分布怪物。</p>
<p>This elevation calculation works for simple islands, which is what I needed for Realm of the Mad God. For continent generation, you’ll want to change this step to generate one or more mountain ranges that aren’t necessarily in the center, as well as isolated volcanos.<br>这种海拔算法适用于简单的岛屿，正是我需要为Realm of the Mad God 准备的。对于生成大陆，你可能想要改变这个算法，来生成一个或多个不在中心的山脉，或者孤立的火山。</p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Unity3D/"> #Unity3D </a>
          
            <a href="/tags/地图/"> #地图 </a>
          
            <a href="/tags/随机/"> #随机 </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/">
                Unity Shaders and Effects Cookbook 翻译 第一章 Diffuse Shading
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-05-23
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/翻译/">翻译</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p></p><h2>Chapter 1:  Diffuse Shading</h2><br>This chapter will cover some of the more common diffuse techniques found in todays Game<br>Development Shading Pipelines. You will learn about:<br>本章覆盖了一些通用的漫反射技术，这些着色器广泛应用于当今的游戏。你可以学到以下知识<br>Creating a basic Surface Shader<br>Adding properties to a Surface Shader<br>Using properties in a Surface Shader<br>Creating a custom diffuse lighting model<br>Creating a Half Lambert lighting model<br>Creating a ramp texture to control diffuse shading<br>Creating a faked BRDF using a 2D ramp texture<br>创建一个基础的表面着色器<br>添加属性到表面着色器<br>在表面着色器中使用属性<br>创建一个自定义的漫反射光照模型<br>创建一个Half Lambert 光照模型<br>使用ramp texture来控制漫反射着色器<br>通过 2D ramp texture来模拟BRDF <p></p>
<p></p><h2>Introduction<br>介绍</h2><br>The beginning of any good Shader always relies on having a foundational diffuse component or lighting model. So it always makes sense to start the Shader writing process with the diffuse component of the Shader.<br>若要写出好的着色器，则必须从基础的漫反射光照模型开始。让我们通过漫反射来迈入着色器的大门。<br>Previously in computer graphics, diffuse shading was done with what was called the fixed function lighting model. It gave graphics programmers just a single lighting model that they could tweak. using a set of parameters and textures. In our current industry. we have access to much more control and flexibility with Cg, and especially in Unity with its Surface Shaders.<br>对老旧的计算机显卡来说，漫反射 是通过固定功能光照模型来实现的。它只允许图形程序员通过一系列参数和纹理来调整一个光照模型。在当今的计算机产业里，我们通过cg语言可以对显卡拥有更多的控制和灵活性，特别是在Unity的表面着色器语言里。<br>The diffuse component of a Shader basically describes the way light reflects off a surface in all directions. That might sound very similar to the description of how a reflective mirror works. but it is actually different. A reflective surface actually reflects the image of the surrounding environment. while diffuse lighting takes all the light from light sources. such as the sun. and reflects its light back to the viewer’s eye. We will be covering reflections in a later chapter. but for our purposes right now. this will help us differentiate between the two.<br>着色器的漫反射功能从根本上解释了灯光是如何在各个角度影响物体表面的，这听起来很像是在描述镜面反射的原理，不过二者确实有所不同。镜面反射实际上反映的是周围的环境，而漫反射则需要处理所有来自光源的光线，比如太阳，并反射回观察者的眼睛。我们会在之后的章节里介绍反射，不过现在这将帮助我们区分二者。<br>To achieve a basic diffuse lighting model. we will have to create a Shader that will include an emissive color. an ambient color. and the total light accumulated from all light sources. The following recipes show you how to build up a complete diffuse lighting model, and also show some various industry tricks that come in handy for creating more complicated diffuse models using only textures.<br>为了为了实现yi’g一个基本的漫反射光照模型，我们要先创建一个着色器，其中包含了自发光和环境光，以及所有从光源发射出的光线。下面的方法将展示如何创建一个完整的漫反射光照模型，并介绍一些广泛使用的技巧，用于在使用一张纹理的时候创建复杂的漫反射着色器。<br>By the end of this chapter you will have learned how to build basic Shaders that perform basic operations Armed with this knowledge, you will be able to create just about any Surface Shader.<br>在本章的最后，你将学会如何用这些知识来创建一个基础的着色器，还可以创建任何表面着色器。<p></p>
<p></p><h2>Creating a basic Surface Shader<br>创建一个基础的表面着色器</h2><br>As we progress further into the recipes in this book, it is important that you know how to set up your workspace in Unity. so that you can work efficiently, and without any pain. If you are already quite familiar with creating Shaders and setting up Materials in Unity 4. you may skip this recipe. It is here to ensure that newcomers to surface shading in Unity 4 can work with the rest of the recipes.<br>通过本书的进一步学习，你必须先懂得如何设置Unity的工作环境。这样会使你更有效率开心的工作。如果你已经非常熟悉如何在Unity里面创建一个着色器和设置材质，那你可以跳过这些步骤，我写下这些只是为了确保新人可以正确的学习下面的知识。<br>Getting ready<br>To get started with this recipe. you will need to have Unity 4 running, and must have created a new project. There will also be a Unity project included with this cookbook, so you can use that one as well and simply add your own custom Shaders to it, as you step through each recipe. With that completed. you are now ready to step into the wonderful world of real-time shading!<br>为了开始本章的学习，你必须先有一份可以运行的Unity4并且创建一个新项目。本书附带了一份Unity工程，你可以使用它，这样可以方便的在后面的学习里添加自定义着色器。当你完成了以上操作后，你就拥有了一个美丽的实时着色器世界。<br>How to do it…<br>如何开始<br>Before getting into our first Shader. let’s create a small scene for us to work with. This can be done by going to GameObject | Create Other in the Unity editor. From there you can create a plane, to act as a ground. a couple of spheres. to which we will apply our Shader. and a directional light to give the scene some light. With our scene generated. we can move onto the Shader writing steps:<br>在开始我们的第一个着色器之前，让我们创建一个工作用的小场景，点击GameObject | Create Other 菜单，然后选择创建Plane ，来充当地面，然后创建一对Spheres，用于演示Shader。然后创建一个directional light 来点亮场景，这样场景就创建完成了，接下来我们讲解创建Shader的步骤：<p></p>
<ol>
<li>In the Project tab in your Unity editor. right-click on the Assets folder and select create l Folder.<br>在Project面板里右键创建一个文件夹<br>【if you are using the Unity project that came with the cookbook. you can skip to step 4.】<br>如果你已经使用了本书附带的Unity项目，请跳过步骤4</li>
<li>Rename the folder that you created to Shaders by right-clicking on it and selecting Rename from the drop-down list, or by selecting the folder and hitting F2 on the keyboard.<br>将文件夹重命名为Shaders</li>
<li>Create another folder and rename it to Materials.<br>创建一个名为Materials的文件夹</li>
<li>Right-click on the Shaders folder and select create l Shader. Then right-click on th Materials folder and select create l Material.<br>在Shaders文件夹里面创建一个Shader，并且在Materials文件夹里创建一个material</li>
<li>Rename both the Shader and the Material to Basicbiffuse.<br>将二者都命名为Basicbiffuse</li>
<li>Launch the Baslcbiffuse Shader into Mononevelop (the default script editor for Unity) by double-clicking on it This will automatically launch the editor for you and display the Shader code.<br>用Mononevelop 打开Baslcbiffuse Shader。<br>【You will see that Unity has already populated our Shader with some basic code. This, by default, will get you a basic diffuse Shader that accepts one texture. We will be modifying this base code so that we can learn how to quickly start developing our own custom Shaders.】<br>【你会发现Unity已经自动在我们的着色器里面填充了一些基础代码，这些代码会帮你创建一个基础的仅用一张纹理的漫反射着色器，我们将在此之上开发，这样就可以更快的学习如何创建一个着色器】</li>
<li>Now let’s give our Shader a custom folder from which it’s selected. The very first line of code in the Shader is the custom description we have to give the Shader so that Unity can make it available in the Shader drop-down list when assigning to Materials. We have renamed our path to Shader “Cookbookshaders/BasicDiffuse “, but you can name it to whatever you want and can rename it at any time. So don’t worry about any dependencies at this point. Save the shader in MonoDevelop and return to the Unity editor. Unity will automatically compile the Shader when it recognizes that the file has been updated. This is what your Shader should look like at this point:<br>现在让我们把着色器放到之前的文件夹里。着色器代码的第一行是我们给这个着色器的自定义描述，用于Unity决定这个着色器出现在材质菜单的哪个位置，将之重命名为”Cookbookshaders/BasicDiffuse ” ，不过你可以在任何时候将之修改为任何你想要的名字。不用担心会有东西依赖于它，在MonoDevelop 里保存文件并返回到Unity里面，它会自动识别是否有更新过并进行编译。现在我们的第一个着色器就像下面的代码一样。</li>
</ol>
<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"CookbookShaders/BasicDiffuse"</span>&#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_MainTex (<span class="string">"Base (RGB)"</span>, <span class="number">2</span>D) = <span class="string">"white"</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;</span><br><span class="line">LOD <span class="number">200</span></span><br><span class="line"> </span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line"><span class="keyword">struct</span> Input &#123;</span><br><span class="line">float2 uv_MainTex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input IN, inout SurfaceOutput o)</span> </span>&#123;</span><br><span class="line">half4 c = tex2D (_MainTex, IN.uv_MainTex);</span><br><span class="line">o.Albedo = c.rgb;</span><br><span class="line">o.Alpha = c.a;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Select the Material called Basicoiffuse that we created in step 4 and look at the Inspector tab. From the Shader drop-down list, select Cookbookshaders l Basicniffuse (your Shader path might be different if you chose to use a different path name). This will assign your Shader to your material and now make it ready for you to assign to an object.<br>在Inspector 选中Basicoiffuse 材质，在右边的Shader列表里选中我们刚创建的Cookbookshaders l Basicniffuse （如果你更改过shader的Path路径，这里将会不一样），然后就可以将这个shader赋值到材质上去，这个材质已经准备好可以在对象上使用了。<br>[To assign a material to an object, you can simply click-and-drag your Material from the Project tab to the object in your scene. You can also drag a Material onto the Inspector tab of an 1 object, within the Unity editor, to assign a Material. ]<br>【你可以通过简单的拖拽材质到项目面板里的一个对象上来赋予材质，也可以拖拽到Inspector面板里的对象上】<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image00.png" alt="image00.png" title="">
Not much to look at, at this point, but our Shader development environment is set up and we can now start to modify the Shader to suit our needs.<br>到此为止我们的开发环境已经设置完毕，现在可以按照我们的需求修改着色器了。</li>
</ol>
<p></p><h1>How it works…<br>工作原理</h1><br>Unity has made the task of getting your Shader environment up and running, very easy for you. It is simply a matter of a few clicks and you are good to go. There are a lot of elements working in the background, with regard to the Surface Shader itself. Unity has taken the Cg Shader language and made it more efficient to write, by doing a lot of the heavy Cg code lifting for you. The Surface Shader language is a more component-based way of writing Shaders. Tasks such as processing your own texture coordinates and transformation matrices have already been done for you, so you don’t have to start from scratch any more. In the past, we would have to start a new Shader and rewrite a lot of code over and over again. As you gain more experience with Surface Shaders, you will naturally want to explore more of the underlying functions of the Cg language and how Unity is processing all of the low-level graphics processing unit (GPU) tasks for you.<br>Unity已经帮你准备好了着色器环境，只是几次简单的点击就可以实现。为了运行表面着色器，有很多元素在后台支撑着它。Unity使用了Cg做为着色器语言，为了使之更方便书写，在后台写了大量的Cg代码。表面着色器是一个基于组件的着色器语，诸如纹理坐标和转置矩阵之类的功能已经准备好了，因此你不必从头开始了。在以前，你为了实现一个着色器，必须重复书写很多代码。在你已经非常熟悉表面着色器之后，你自然会想要探索更多未知的幕后，比如cg语言和Unity是如何在底层的GPU上执行低级图形运算的。<br>So, by simply changing the Shader’s path name to a name of our choice, we have got our basic diffuse Shader working in the Unity environment, working with lights and shadows and all that, by just changing one line of code!<br>因此，通过简单的更改着色器路径名，我们已经拥有了一份可以在Unity下运行的基础漫反射着色器，并且灯光和阴影正常工作。而这一切，只是改变一行代码而已！<p></p>
<p></p><h2>See also<br>参考</h2><br>For more information on where to find a large portion of the built-in Cg functions for Unity. go to your Unity install directory and navigate to Unity4\Edittor\Data\CGIncludes. Within that folder there are three files that are of note at this point. the UnityCG.cginc. Lighting.cginc. and UnityShaderVariables.cginc. Our current Shader is making use of all these files at the moment.<br>下面讲解如何找到Unity自带的Cg代码，在你Unity安装目录下的Unity4\Edittor\Data\CGIncludes.里，有三个文件是需要注意的，UnityCG.cginc Lighting.cginc. 和 UnityShaderVariables.cginc。我们目前的着色器正在使用这三个文件里的功能。<br>We will go more in-depth with Cglnclude files in Chapter 9. Making Your Shader World Modular with Cglncludes.<br>我们会在第九章深入讲解Cglnclude文件里的接口。<p></p>
<p></p><h2>Adding properties to a Surface Shader<br>在表面着色器里加入属性</h2><br>Properties of a Shader are very important to the Shader pipeline, as they are the method you use to let the artist or user of the Shader assign textures. and tweak your Shader values. Properties allow you to expose GUI elements in a Material’s Inspector tab without you having to use a separate editor. which provides visual ways to tweak a Shader.<br>着色器的属性在渲染管道过程里是很重要的，因为它们是让艺术家或使用者分配纹理或调整着色器值的接口。属性可以做为GUI属性暴露在材质的检视面板上，而不需要单独的设置，它提供了可视化的方法供你调整着色器。<br>With your Shader opened in MonoDevelop. look at the block of lines 3 through 6. This is called the Properties block. Currently. it will have one property in it called _MainTex. If you look at your Material that has this Shader applied to it. you will notice that there is one texture GUI element in the Inspector tab. These lines of code, in our Shader. is creating this GUI element for us.<br>用MonoDevelop打开你的着色器，看第三行到第六行，这些就是着色器的属性，目前我们只有一个名为_MainTex的属性，如果你查看对应的材质，你会注意到检视面板上有个对应的纹理GUI元素，这个是依赖于代码里的属性自动生成的。<br>Again. Unity has made this process very efficient in terms of coding and the amount of time it takes to iterate through changing your properties<br>再次声明，Unity通过代码很有效率的实现了这个功能，它通过遍历属性来完成这个过程。<p></p>
<p></p><h2>How to do it…<br>怎么去实现</h2><br>Let’s see how this works in our current Shader called BasicDiffuse. by creating our own properties and learning more about the syntax involved:<br>让我们通过创建自己的着色器属性，来了解所涉及到的语法在BasicDiffuse着色器里是如何工作的。<p></p>
<ol>
<li>In our Properties block of our Shader. remove the current property by deleting the following code from our current Shader.<br>1.在我们的着色器属性里，删除下面的属性代码<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main’I‘ex (“Base (RG8) ” , <span class="number">20</span>) = “white”</span><br></pre></td></tr></table></figure></li>
<li>Now enter the following code. save the Shader. and re-enter the Unity editor.<br>2.然后输入下面的代码，并保存着色器，然后再次打开Unity编辑器<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_EmissiveColor (“Emissive Color”, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li>when you return to Unity. the Shader will compile and you will see that our Materials Inspector tab now has a color swatch. named Emlsslve color. instead of a texture swatch. Let‘s add one more and see what happens. Enter the following code:<br>3.当你返回到Unity时，着色器已经完成了编译，并且你可以看到在材质检视面板上出现了一个名为Emlsslve color的颜色样本，它替换掉了之前的纹理样本。接下来再次输入下面的代码：<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_AmbientColor (“Ambient Color”, Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li>We have added another Color Swatch to the MateriaI’s Inspector tab. Now let’s add one more to get a feel for other kinds of properties that we can create. Add the following code to the properties block:<br>我们已经在材质面板上添加另一个颜色属性，现在让我们来添加其他类型的属性，请输入下面的代码：<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_MySliderValue (“This is a Slider”, Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">2.5</span></span><br></pre></td></tr></table></figure></li>
<li>We have now created another GUI element that allows us to visually interact with our Shader. This time we created a slider with the name This is a Slider. as shown in the following screenshot:<br>现在你可以看到面板上出现了另一种GUI元素，这次我们创建的是一个滑动条，就像你在屏幕上看到的那样：<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image11-300x101.png" alt="image11-300x101.png" title="">
Properties allow you to create a visual way to tweak Shaders without having to change values in the Shader code itself.<br>属性可以让你创建一个可视化面板来调整你的着色器，而不需要去更改代码。<br><h2>How it works…<br>它是如何工作的</h2><br>Every Unity Shader has a built-in structure it is looking for in its code. The properties block is one of those functions that is expected by Unity. The reason behind this is to give you. the Shader programmer. a means of quickly creating GUI elements that tie directly into your Shader code. These properties that you declare in the properties block can then be used in your Shader code to change values. colors. and textures<br>每一个Unity着色器都拥有如下的内置结构，这些属性块则是Unity所希望带给你的功能之一。之所以这样做，是希望给你，给图形程序员一种快捷的方式来创建Gui元素并和你的着色器代码绑定。这些你申明的属性块可以在接下来的代码里用于调整颜色或者纹理。<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image09.png" alt="image09.png" title="">
Let’s take a look at what is going on underneath the hood here. when you first start writing a new property. you will need to give it a Variable Name. The variable name is going to be the name that your Shader code is going to use to get the value from the GUI element. This saves us a lot of time because we don‘t have to set up that system ourselves.<br>让我们来看看Unity引擎在背后都做了那些工作，当你开始添加一个新的属性后，你必须赋予它一个名字，而这个名字就是你的着色器代码从Gui面板获取属性的方法，这节省了我们大量的时间，因为我们不需要亲自去完成这个系统。<br>The next elements of a property are the Inspector GUI Name and the type of the property. which is contained within parentheses. The Inspector GUI Name is the name that is going to appear in the Materials Inspector tab when the user is interacting with and tweaking the Shader. The Type is the type of data that this property is going to control. There are many types that we can define for properties inside of Unity Shaders. The following table describes the types of variables we can have in our Shaders:<br>接下来介绍出现在Gui面板的属性名字和类型，Gui的名字就是出现在材质面板里的属性名字，这是用于调整着色器的，属性的数据类型就是我们控制的。Unity提供了很多类型让我们在着色器里使用，可以参看下面的表格：<h3>Surface Shader property types</h3>

</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>Range (min. max)</td>
<td>This creates a float property as a slider from the minimum value to the maximum value 创建一个float属性，可以创建一个标注最大最小值的滑动条</td>
</tr>
<tr>
<td>Color</td>
<td>This creates a color swatch in the lnepeceor tab that opens up a color picker – (fIoat.float.float.float)定义颜色属性，可以使用颜色采样器UI</td>
<td></td>
</tr>
<tr>
<td>2D</td>
<td>This creates a texture swatch that allows a user to drag a texture into the Shader创建纹理属性，可以直接拖拽一个纹理进去</td>
</tr>
<tr>
<td>Rect</td>
<td>This creates a non-power-of-2 texture swatch and functions the same as the 2D GUI element创建一个非2次方的纹理属性，就像2D属性一样</td>
</tr>
<tr>
<td>Cube</td>
<td>This creates a cube map swatch in Inspector and allows a user to drag-and-drop a cube map into the Shader创建一个立方贴图属性，你可以直接拖拽立方贴图上去</td>
</tr>
<tr>
<td>Float</td>
<td>This creates a float value in Inspector but without a slider创建一个非滑动条的float属性</td>
</tr>
<tr>
<td>Vector</td>
<td>This creates a four-float property that allows you to create directions or colors创建拥有四个float的属性，你可以用于标记方向或颜色</td>
</tr>
</tbody>
</table>
<p>Finally, there is the default value. This simply sets the value of this property to the value you place in the code. So. in the example image. the default value for the property named _AmbientColor, which is of the type Color. is set to a value of 1 , 1 , 1 , 1. Since this is a color property expecting a color. which is RGBA or a float4. or r, g, b, a = x, y, z,w this color property. when it is first created. is set to white.<br>最后，这些属性都拥有默认值，代码里的属性会被快速赋予默认值。因此，在示例里，由于_AmbientColor的类型是Color，所以默认值被设为 1 , 1 , 1 , 1。这四个值代表RGBA 或者float4，或者r, g, b, a = x, y, z,w，当它第一次创建后，就被设置为白色。</p>
<p></p><h2>See also<br>参考</h2><br>The properties are documented in the Unity manual at <a href="http://docs.unity3d.com/Documentation/Components/SL-Properties.html" target="_blank" rel="external">http://docs.unity3d.com/Documentation/Components/SL-Properties.html</a><br>这些属性都记录在Unity手册里，网址是<a href="http://docs.unity3d.com/Documentation/Components/SL-Properties.html" target="_blank" rel="external">http://docs.unity3d.com/Documentation/Components/SL-Properties.html</a><br>Using properties in a Surface Shader<br>在表面着色器里使用属性<br>Now that we have created some properties. let’s actually hook them up to the Shader so we can use them as tweaks to our Shader and make the material process much more interactive.<br>现在我们已经创建了一些属性，让我们将之和着色器关联起来，以让我们可以使用属性来调整着色器并让材质获得更多的交互。<br>We can use the properties‘ values from the MateriaI’s Inspector tab because we have attached a variable name to the property itself. but in the Shader code you have to set a couple things up before you can start calling the value by its variable name.<br>我们可以在材质面板调整属性，因为已经为属性赋予了一个变量名，不过你要想在着色器代码里通过变量名来获得对应的属性，则必须创建与之相互呼应的另一个变量。<br>How to do it…<br>怎么实现<br>The following steps show you how to use the properties in a Surface Shader:<br>接下来为你展示如何在表面着色器中使用属性<p></p>
<ol>
<li>To begin. let’s remove the following lines of code. as we deleted the property called MainTex in the Creating a basic Surface Shader recipe of this chapter:<br>首先，让我们删除以下代码，这是本章中添加的MainTex 属性。<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;</span><br><span class="line">half4 c = tex2D (_MainTex, IN.uv_MainTex);</span><br></pre></td></tr></table></figure></li>
<li>Next, add the following lines of code to the Shader. below the  CGPROGRAM line:<br>然后在CGPROGRAM 标记下面添加以下代码<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float4 _EmissiveColor;</span><br><span class="line">float4 _AmbientColor;</span><br><span class="line"><span class="keyword">float</span> _MySliderValue;</span><br></pre></td></tr></table></figure></li>
<li>With step 2 complete, we can now use the values from the properties in our Shader. Let’s do this by adding the value from the _EmissiveColor property to the Ambientcolor property. and giving the result of that to the o.Albedo line of code. So. let’s add the following code to the Shader inside the surf function:<br>当你完成步骤2之后，你就可以在着色器里使用属性值了。让我们将_EmissiveColor 和Ambientcolor 的值想加，然后把计算结果赋值给 o.Albedo 。加入以下代码到surf函数里。<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input IN, inout SurfaceOutput o)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">float4 c;</span><br><span class="line">c = <span class="built_in">pow</span>((_EmissiveColor + _AmbientColor), _MySliderValue);</span><br><span class="line">o.Albedo = c.rgb;</span><br><span class="line">o.Alpha = c.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Finally, your Shader should look like the following Shader code. If you save your Shader in Monooevelop and re-enter Unity, your Shader will compile. If there were no errors, you will now have the ability to change the ambient and emissive colors of the Material, as well as increase the saturation of the final color by using the slider value.Pretty neat. huh!<br>完成后的代码应该和下面一样，如果你保存了着色器代码并返回到Unity之后，应该会看到着色器在自动编译。如果没有错误，你现在可以在材质里修改ambient 和emissive 属性的颜色值了，让我们通过滑动条来增加这些属性的饱和度。<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">"CookbookShaders/BasicDiffuse"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//We define Properties in the properties block</span></span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">_EmissiveColor (<span class="string">"Emissive Color"</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_AmbientColor (<span class="string">"Ambient Color"</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_MySliderValue (<span class="string">"This is a Slider"</span>, Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">2.5</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">Tags &#123; <span class="string">"RenderType"</span>=<span class="string">"Opaque"</span> &#125;</span><br><span class="line">LOD <span class="number">200</span></span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line"><span class="comment">//We need to declare the properties variable type inside of the CGPROGRAM so we can access its value from the properties block.</span></span><br><span class="line">float4 _EmissiveColor;</span><br><span class="line">float4 _AmbientColor;</span><br><span class="line"><span class="keyword">float</span> _MySliderValue;</span><br><span class="line"><span class="keyword">struct</span> Input</span><br><span class="line">&#123;</span><br><span class="line">float2 uv_MainTex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input IN, inout SurfaceOutput o)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="comment">//We can then use the properties values in our shader</span></span><br><span class="line">float4 c;</span><br><span class="line">c = <span class="built_in">pow</span>((_EmissiveColor + _AmbientColor), _MySliderValue);</span><br><span class="line">o.Albedo = c.rgb;</span><br><span class="line">o.Alpha = c.a;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
【The pcw(arg1 , arg2) is a built-ln function that will perform the equivalent math functlon of power. So, argument 1 is the value we want to raise to a power, and argument 2 ls the powet we want to rabe It to.<br>pcw(arg1 , arg2)是自带的函数，相当于数学函数里的power。代表x的y次方<br>To flnd out more Information about the pow () function, look to the Cg tutorial. It Is a great free resource that you can use fol Ieamlng more about shading and to get a glossary of all the functions available to you In the Cg shading language:<br>你可以翻阅Cg教程。这是一份很好的教程，你可以查阅各种着色器能够使用的函数名。<br><a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html】" target="_blank" rel="external">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_e.html】</a><br>The following screenshot demonstrates the result obtained by using our properties to control our Materials colors and saturation. from within the Material’s Inspector tab:<br>下面这个截图展示了在材质面板调整颜色和饱和度之后的样子<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image06.png" alt="image06.png" title="">
when you declare a new property in the property block. you are providing a way for the Shader to retrieve the tweaked value from the Materials Inspector tab. This value is stored in the variable name portion of the property. In this case. _AmbienColor. _EmissiveColor. and _MySliderValue are the variables in which we are storing the tweaked values. In order for you to be able to use the value in the subshader{ } block. you need to create three new variables with the same names as the property‘s variable name. This automatically sets up a link between these two so they know they have to work with the same data. Also. it declares the type of data we want to store in our subshader variables. which will come in handy when we look at optimizing Shaders in a later chapter.<br>当你在属性区申明了一个新属性之后，着色器就提供了一种从材质面板获得调整后的属性值的方法，这些值保存在对应的变量名里。在我们的着色器里_AmbienColor. _EmissiveColor.<br>和 _MySliderValue这些变量保存着你调整后的值。为了能在subshader里使用这些值，你需要创建三个和属性一样名字的变量，unity会自动将二者关联在一起，它们拥有同样的数据。同样，这些变量的数据类型将会在后面的优化章节里用到。<br>Once you have created the subshader variables. you can then use the values in the surf function. In this case we want to add the _EmissiveColor and _AmbientColor variables together and take it to a power of whatever the _MySliderValue variable is equal to in the Material’s Inspector tab.<br>当你在subshader里创建好变量后，你就可以在surf函数里使用它们了。在这个例子里，我们希望把_EmissiveColor 和 _AmbientColor 以及_MySliderValue 变量通过power函数叠加在一起。<br>We have now created the foundation for any Shader you will create that requires a diffuse component.<br>现在我们创建了一个任何着色器都可以使用的漫反射函数。<br><h2>Creating a custom diffuse lighting model<br>创建自定义漫反射光照模型</h2><br>Using Unity’s built-in lighting functions is all well and good. but you will quickly outgrow these and want to create a lot more custom lighting models Speaking from experience. we have never worked on a project that has used just the built-in Unity lighting functions and called it good. We would create custom lighting models for just about everything This would allow us to do things such as produce rim lighting effects. more Cubemap-based types of lightings. or even control over how your Shaders react to gameplay. as seen in Shaders that control force fields<br>Unity自带的光照函数已经很棒了，不过你需要通过创建大量自定义光照模型来获得进步。我们永远不能说一个只使用自带光照模型的项目是个好项目。我们希望创建自定义光照模型来实现各种效果，比如它允许我们实现边缘高亮，以及更多的基于立方贴图的光照。甚至控制你的着色器如何对游戏进行反馈，显然它可以控制一切。<br>This recipe will focus on creating our own custom diffuse lighting model that we can use to modify and create a number of different effects.<br>下面让我们来看看如何创建自定义光照模型，并用它创建出各种各样的效果。<br><h2>How to do it…<br>如何实现</h2><br>Using the basic diffuse Shader we created in the last recipe. let’s modify it again by performing the following steps:<br>使用我们在前面创建的着色器，让我们通过下面的步骤来修改它：</li>
<li>Let’s modify the #pragma statement to the following code:<br>将#pragma标记修改如下<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> surface surf BasicDiffuse</span></span><br></pre></td></tr></table></figure></li>
<li>Add the following code to the subshader:<br>加入下面代码<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> float4 <span class="title">LightingBasicDiffuse</span> <span class="params">(SurfaceOutput s, fixed3 lightDir, fixed atten)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> difLight = max(<span class="number">0</span>, dot (s.Normal, lightDir));</span><br><span class="line">float4 col;</span><br><span class="line">col.rgb = s.Albedo * _LightColor0.rgb * (difLight * atten * <span class="number">2</span>);</span><br><span class="line">col.a = s.Alpha;</span><br><span class="line"><span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Save the Shader in MonoDevelop and return to Unity. The Shader will compile. and if everything went well. you will see that no real visible change has happened to our Material. What we have done is removed the connection to the built-in Unity diffuse lighting and created our own lighting model that we can customize.<br>保存着色器代码并返回Unity窗口，着色器会自动编译。如果没问题的话你就可以看到材质已经发送了变化，我们前面所有的工作都是为了实现删除Unity自带的漫反射光照并且实现了一个自定义光照模型。<br><h2>How it works…<br>如何工作</h2><br>There are definitely a lot of elements working here. so let’s try to break it down piece by piece and learn why this works in the way that it does:<br>可以清楚的看到上面我们加入了很多代码，现在让我们一行行来解释它是如何工作的：<br>The #pragma surface directive tells the Shader which lighting model to use for its calculation. It worked when we first created the Shader because Lambert is a lighting model defined in the Lighting.cginc file. So it was able to use this on creation. We have now told the Shader to look for a lighting model by the name BaseDiffuse.<br>pragma指令告诉着色器将使用哪个光照模型来计算。在我们创建的第一个着色器代码里，默认使用Lighting.cginc文件里包含的Lambert 光照模型，所以可以计算光照。现在我们告诉着色器将使用名叫BaseDiffuse的光照模型。<br>Creating a new lighting model is done by declaring a new lighting model function.Once you have done that, you simply replace the function’s name with a name of your choice. For example. LightingName becomes Lighting&lt; Your Chosen Name&gt;<br>通过创建一个新的光照模型函数就能实现光照了，当你完成这个步骤后，可以将函数名替换成你想要的名字。函数名的格式是：Lighting&lt;任何名字&gt;<br>There are three types of lighting model functions that you can use:<br>你能够使用三种格式的光照模型函数<br>half4 LightingName (surfaceoutput s, half3 lightDir,half atten){}<br>This function is used for forward rendering when the view direction is not needed.<br>上面这个函数用于不需要视角方向的前向渲染<br>ha1f4 LightingName (surfaceoutput s, ha1f3 lightDir, half3 viewDir, half atten){}<br>This function is used in forward rendering when a view direction is needed.<br>这个函数用于需要视角方向的前向渲染<br>ha1f4 LightingName _PrePass (surfaceoutput s, half4 lignt}<br>This function is used when you are using deferred rendering for your project.<br>此函数用于延迟渲染<br>The dot product function is another built-in mathematical function in the Cg language. We can use it to compare the directions of two vectors in space. The dot product<br>checks whether two vectors are either parallel to each other or perpendicular. By gving the dot product function, for two vectors you will get a float value in the range<br>of -1 no 1: where -1 is parallel and has the vector facing away from you, 1 is parallel and has the vector facing toward you, and 0 is completely perpendicular to you.<br>dot函数是cg语言的另一个内置函数，我们可以用它来比较两个向量在空间里的方向。dot函数会检查两个向量是互相平行还是垂直。任意两个向量都可以通过dot函数获得一个范围，区间是 -1到1，-1就是平行表示向量远离你，1代表朝向你的向量，0表示和你垂直。<br>The vector dot product (or inner product) of the normalized vectors N and L is a measure of the angle between the two vectors. The smaller the angle between the vectors. the greater the dot-product value will be. and the more incident light the surface will receive.<br>归一化的向量间的dot计算是估算夹角的一种方法，夹角越小，则dot值越大，并且表面可以接收到更多的入射光<br><h2>Reference:<br>参考</h2><br><a href="http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter05.html" target="_blank" rel="external">http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter05.html</a><br>To complete the diffuse calculation, we need to multiply it with the data being provided to us by Unity and by the surfaceoutput struct. For this we need to multiply the a.Albedo value (which comes from our surf function) with the incoming _LightColor0.rgb value (which Unity provides), and then multiply the result of that with (difLight <em> atten) . Then, finally, return that value as the color. See the following code:<br>为了完成漫反射计算，我们需要将Unity提供给我们的数据乘上SurfaceOutput结构。为此我们需要乘上a.Albedo（来自上SurfaceOutput） 和_LightColor0.rgb（来自Unity） 然后再将结果与(difLight </em> atten) 相乘，最后，返回这个值做为颜色。请看下例<figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> float4 <span class="title">LightingBasicDiffuse</span> <span class="params">(SurfaceOutput s, fixed3 lightDir, fixed atten)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> difLight = max(<span class="number">0</span>, dot (s.Normal, lightDir));</span><br><span class="line">float4 col;</span><br><span class="line">col.rgb = s.Albedo * _LightColor0.rgb * (difLight * atten * <span class="number">2</span>);</span><br><span class="line">col.a = s.Alpha;</span><br><span class="line"><span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
The following screenshot demonstrates the result of our basic diffuse Shader:<br>下面这个截图展示了我们的基础man’fan’s下面这个截图展示了我们的漫反射着色器结果<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image02.png" alt="image02.png" title="">
<h2>There’s more…<br>更多</h2><br>By using the built-in Cg function called max, we can clamp the values that get returned from the dot product function. The max function takes two arguments. max (arg1, arg2 ) . We are using it in our Shader to make sure the values we are using for our diffuse calculation are between 0 and the maximum of the dot product .This way we will never get a value below 0. especially not -1, which would create extremely black areas in your Shader that wouldn’t play well with your Shader math later in the Shader process.<br>通过cg自带的max函数，我们可以限制dot计算结果。max函数采用两个参数max (arg1, arg2 ) ，我们在着色器里通过max来确保漫反射的计算结果永远落在0和dot的最大值之间。这样你就永远不会获得小于0的值，甚至-1，否则可能会在你的着色器区间生成黑色区域，并且在你之后的着色器运算过程中容易出问题。<br>There is also the saturate function within the Cg function library. This helps us to clamp<br>float values between 0 and 1 as well. The only difference between max () and saturate<br>is that you simply feed your float value into saturate. The max function takes two arguments<br>and returns the maximum value between the two.<br>除此之外cg里还有个类似saturate函数，可以帮助我们将float值限制到0和1之间。saturate和max的区别就是saturate可以直接将float值转换成饱和度。max函数接受两个参数并返回二者之间最大的值。<br>See also<br>You can find more infonnation on the Surface Shader lighting model function<br>arguments at<br>你可以在下面的网址找到更多的表面着色器光照的信息<a href="http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html" target="_blank" rel="external">http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html</a></li>
</ol>
<hr>
<p></p><h2>Creating a Half Lambert lighting model<br>创建Half Lambert光照模型</h2><br>Half Lambert was a technique created by Valve as a way of getting the lighting to show the surface of an object in low-light areas. It basically brightens up the diffuse lighting of the Material and wraps the diffuse light around an object’s surface.<br>Half Lambert 是一种用于在低光照区域照亮物体的技术，它基本上加亮了材质的漫反射光照以及环绕物体表面的漫反射灯光。<br>“Harf Lambert” lighting is a technique first developed in the original Half-Life (<a href="https://developer.valvesoftware.com/wiki/Half-Life" target="_blank" rel="external">https://developer.valvesoftware.com/wiki/Half-Life</a> ). it is designed to prevent the rear of an object losing its shape and looking too flat. Half Lambert is a completely nonphysical technique and gives a purely perceived visual enhancement. it is an example of a forgiving lighting model.<br>Harf Lambert技术最早应用于原始的半条命游戏。设计用于防止一个物体的背后失去形状看起来过于扁平，Half Lambert完全是一个非物理的技术，并给出了一个纯粹的感知视觉增强。它是高包含度光照模型的一个例子。<p></p>
<p></p><h2>Reference:<br>参考</h2><br><a href="https://developer.valvesoftware.com/wiki/Half_Lambert" target="_blank" rel="external">https://developer.valvesoftware.com/wiki/Half_Lambert</a><p></p>
<p></p><h2>How to do it…<br>如何实现</h2><br>Using the basic Shader that we created in the last recipe. let’s update the diffuse calculation<br>by following the next step:<br>首先使用我们在前面创建的基础着色器，让我们通过下面步骤来升级漫反射计算<br>Modify the diffuse calculation by multiplying it by 0.5. So. you would add the following<br>code to your lighting function:<br>将漫反射计算结果乘上0.5，然后，将下面的代码加入到你的光照函数里<br><img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image01-300x82.png" alt="image01-300x82.png" title=""><br>The following screenshot demonstrates the result of the implementation of the Half Lambert<br>technique into our Shader’s Iighting model:<br>下面的截图展示了将Half Lambert技术加入到我们的着色器光照模型后的结果<p></p>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image08.png" alt="image08.png" title="">
<p></p><h2>How it works…<br>工作原理</h2><br>The Half Lambert technique works by taking the range of values of the diffuse lighting dividing it in half. and then adding 0.5 back to it. This basically means that if you have a value of 1 and you cut it in half. you will have 0.5. Then, if you add 0.5 back to it. you will have 1 again. If you did this same operation to a value of 0. you would end up with 0.5. So, we have taken a range of values from 0 to 1 and re-mapped it to be within a range of 0.5 to 1.0. The following shows the diffuse value mapped to a function graph. showing the result of the Half Lambert calculation:<br>Half Lambert实现的原理是把漫反射光照除2然后加上0.5。意思就是如果你的值是1，对半开后就是0.5，然后你再加0.5回去，将会再得到1。如果你对0进行操作，那么你会得到0.5，因此我们将0到1之间的所有值重新映射到0.5和1的区间。下面展示了漫反射的值经过Half Lambert计算后的函数曲线图。<p></p>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image00.png" alt="image00.png" title="">
<p></p><h2>Creating a ramp texture to control diffuse shading<br>创建一个梯度纹理来控制漫反射着色</h2><br>Another great tool in your Shader writing toolbox is the use of a ramp texture to drive the color of the diffuse lighting. This allows you to accentuate the surface’s colors to fake the effects of more bounce light or a more advanced lighting setup. You see this technique used a lot more for cartoony games. where you need a more artist-driven look to your Shaders and not so much of a physically~accurate lighting model.<br>在你的着色器工具箱里还有个伟大的工具，那就是用一个梯度纹理来控制漫反射的颜色。这允许你突出表面的颜色，来模拟更多的光照或者更先进的灯光设置。你应该在很多卡通游戏里看到过这种技术的使用，当你不想要真实物理模拟的光照而是更艺术化的显示时，你会需要它的。<br>This technique became more popular with Team Fortress 2. where Valve came up with a unique approach to lighting their characters. They produced a very popular white paper on the subject. and you should definitely give it a read.The Valve White Paper on Team Fortress 2 Lighting and shading available at<br>这个技术随着Team Fortress 2游戏而开始流行，因为Value创造出了一种全新的方法来照亮他们的角色。他们还写了一本非常流行的白皮书，你绝对应该去看看。通过下面地址访问白皮书 <a href="http://www.valvesoftware.com/publications/2007/NPAR07_IllustrativeRenderingInTeamFortress2.pdf" target="_blank" rel="external">http://www.valvesoftware.com/publications/2007/NPAR07_IllustrativeRenderingInTeamFortress2.pdf</a><p></p>
<p></p><h2>Getting ready<br>准备</h2><br>To get this started you will need to create a ramp texture in some image editing application. We used Photoshop for this particular demonstration. but any image editing application should be able to make a gradient<br>首先你需要用图像编辑软件创建一张梯度纹理，在这里我们提供了一张用Photoshop制作的特殊图片，不过不管哪个图像编辑软件应该都可以制作梯度纹理。<p></p>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image05.png" alt="image05.png" title="">
<p></p><h2>How to do it…<br>如何做</h2><br>Let’s begin our Shader by entering the following code:<br>让我们通过下面代码来开始学习<br>Simply modify the lighting function so that it includes this new code:<br>像下面这样修改之前的光照函数<p></p>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image04-300x87.png" alt="image04-300x87.png" title="">
<p>The following is the result you will see after running the code:<br>运行代码之后你就可以看到下图展示的结果了</p>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image12.png" alt="image12.png" title="">
<p></p><h2>How it works…<br>工作原理</h2><br>This line of code is returning a set of colors. or a float3. which is also the same as r. g. b. These colors are being produced by a Cg function called tex2D. The tex2D () function takes two arguments The first is the texture property we use for this operation. The second includes the UVs from the model that we want to map to the texture.<br>这行代码返回了一个颜色集，或者叫float3，相等于r.g.b三个属性，这些颜色是通过tex2D的cg函数生成的。tex2D函数有两个参数，第一个是我们使用的纹理，第二个值包含了一个我们希望映射到这张纹理的uv坐标。<br>In this case we do not want to use any UVs from a vertex. but instead we want to use the diffuse float range to map the UVs of the ramp texture. This ultimately wraps the ramp texture around the surface of the object. based on the direction to the light being calculated.<br>在这种情况下我们不希望使用顶点的uv值，而是用漫反射值来替换它来当作uv坐标映射到梯度纹理。最终将根据灯光计算后的方向来映射整个梯度纹理到物体的表面。<br>We take the re-mapped diffuse values from the Half Lambert operation and pass them into float2 () to create the lookup values for the texture. When a value of 0 is set as the hLambert variable. the tex2D function looks up the pixel value at the UV value of (0.0). In this case it’s the subtle peach color from the ramps gradient. when a value of 1 is set for the hLal’nbert variable. the tex2D function looks up the pixel at the UV value of (1.1). or the white color.<br>我们使用Half Lambert计算并重新映射的漫反射，并将之转换成float2类型从而创建纹理搜索值。当hLambert值为0时，tex2D函数会去搜索(0,0)UV坐标处的像素，在我们的示例里它会呈现梯度纹理对应的蜜桃色，当值是1是则会返回(1,1)处的白色。<br>Now it is possible for the artist to have some custom control over how the light looks on the surface of an object. This is why this technique is more commonly seen on a project where you need more of an illustrative look.<br>现在开始艺术家就拥有了一些自定义方法来控制灯光在物体表面的效果。因此这就是这个技术如此常见的原因，因为你需要更多的直观展示效果。<br>Creating a faked BRDF using a 2D ramp texture<br>用2D梯度纹理来模拟BRDF效果<br>We can take the ramp diffuse recipe one step further by using the view direction, provided by the lighting functions. to create a more advanced visual look to our lighting. By utilizing the view direction. we will be able to generate some faked rim lighting。<br>我们可以使用光照函数和视角方向生成的梯度漫反射结果来创建一个高级可视化效果，利用视角方向我们能够生成一些模拟的边缘光照。<br>If we look at the ramp diffuse technique. we are only using one value to place into the UV lookup of the ramp texture. This means that we will get a very linear type of lighting effect. In this recipe we will change our lighting function to take advantage of an additional argument. the view direction.<br>让我们回头来看看梯度纹理技术，可以看到我们才用了一个值来控制纹理的UV坐标，这意味着我们只能得到一个线性的光照效果。在这节我们会在光照函数里加入额外的视角参数来获得更好的效果。<br>The view direction is the user’s view of the object itself. It is a vector. pointing in a direction that we can use in conjunction with the normal and light direction. This view vector will provide us with the means to create a more advance texture lookup.<br>视角方向指的是我们看向物体自身的视线方向，这是一个向量，标注了方向，这意味着我们可以将之与法线以及灯光方向结合使用。来创建一个更先进的纹理查找技术。<br>In the Cg industry this technique is often referred to as a BRDF effect BRDF stands for bidirectional reflectance distribution function. While that is a mouthful. it simply means the way in which light is reflected off an opaque surface from both the view direction and the light direction. To see the effects of this BRDF Shader. let’s continue by setting up our scene and writing the Shader.<br>在CG行业这个技术通常叫做BRDF技术，代表双向反射分布函数。虽然这很拗口，简单来说就是光线在不透明物体表面被同时反射到视角和灯光两个方向。为了展示这种效果，让我们来设置环境并书写着色器<br>Getting ready<br>Before starting we will need a more embellished ramp texture this time. We need to include gradients for both dimensions of the texture.<br>开始前让我们先来修改下梯度纹理，我们需要让它包含两个方向的渐变。<p></p>
<ol>
<li>Create a new texture with a size of 512 x 512.<br>创建一张512 x 512.的纹理</li>
<li>Create a gradient, diagonally starting from the bottom left of the image, going to the<br>top-right of the image.<br>从左下角到右上角创建一个梯度对角效果</li>
<li>Create another gradient from the top-left side. going until just before the middle of<br>the image.<br>同样从左上角再拉一条渐变效果，直到覆盖底部</li>
<li>Finally, create another ramp from the bottom-right side to just before the middle of<br>the image. You should end up with a texture shown in the following image:<br>最后，从右下角再创建一个渐变效果，最后，你会获得下图的图像</li>
</ol>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image03.png" alt="image03.png" title="">
<p>How to do it…<br>Let’s go through this recipe by following the next few steps. using the basic diffuse Shader as our starting point:<br>让我们通过下面步骤来开始本节的学习，还有我们需要在前面创建的基础漫反射着色器上工作。</p>
<ol>
<li>First we need to change our lighting function to include the viewDir variable that Unity provides us, to get the current view direction of the camera in the scene as it looks at our object. Modify your lighting function to look like the following code:<br>首先我们需要修改光照函数并加入Unity提供的视角变量，这样我们就可以获得当前场景的摄像机看此物体的方向，按照下图来修改你的代码：</li>
</ol>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image16-300x76.png" alt="image16-300x76.png" title="">
<ol>
<li>We then need to calculate the dot product of the view direction and the surface normal (as shown in the following code). This will produce a falloff type effect that we can use to drive our BRDF texture.<br>然后我们须将视角方向和表面法线进行点积运算，这样可以创建一个衰减效果用于展示BRDF纹理</li>
</ol>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image10-300x82.png" alt="image10-300x82.png" title="">
<ol>
<li>To complete the operation. we need to feed our dot product result into the float2 function of the tex2D( ) function. Modify your lighting function to the following code:<br>为了完成操作，还需要将点积的结果转换成float2类型来进行tex2D运算，按照下图来修改代码</li>
</ol>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image14-300x82.png" alt="image14-300x82.png" title="">
<ol>
<li>Save your Shader and re-enter Unity. Make sure you are using your new BRDF texture as the ramp texture in Unity. You should notice that your lighting now includes two rim light type effects: one for the bottom of the model and one for the top.<br>保存并再打开Unity，确保BRDF纹理已经在Unity里，然后你会发现你的光照函数产生了两种边缘高亮效果，上面和下面各一种效果。<br>The following image demonstrates the results of using a BRDF ramp texture to drive the overall diffuse color. This technique is great for a production team as it makes it easy for an artist to update a texture, in Photoshop. rather than tweak Iightinig in the game:<br>下图演示了使用BRDF渐变纹理带动整体漫反射颜色的结果。对于团队来说这是一个伟大的发明，因为它很容易让一个艺术家通过Photoshop来升级纹理效果。而不是在游戏中调整灯光。</li>
</ol>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image07-300x244.png" alt="image07-300x244.png" title="">
<p></p><h2>How it works…<br>运行原理</h2><br>when using the view direction parameter, we can create a very simple falloff type effect. You can use this parameter to create a lot of different types of effects: a bubble type transparency. the start of a rim light effect. shield effects, or even the start of a toon outline effect.<br>当使用视角方向参数的时候，我们可以创建一个简单的衰减效果。你可以使用这个参数来制作任何不同类型的效果：一个透明的泡泡，边缘高光效果，盾牌效果，甚至可以制作卡通边缘线效果。<p></p>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image15-300x294.png" alt="image15-300x294.png" title="">
<p>The preceding image shows the dot product of the view direction and the surface nonnal. Consider if you were to look at the values being produce by taking the dot product of the view direction and the surface normal.<br>考虑到如果你想要看视角和发现点击的值的话，上面的截图展示了视角方向和表面法线点击的效果<br>In this case we are using it as one of the components in the BRDF ramp texture lookup. Since the diffLight calculation and the rimLight calculation both produce a linear range of values from 0 to 1, we can use both the ranges to pick different areas of the ramp texture.<br>在这种情况下我们将之做为BRDF 梯度纹理查找的条件之一，由于diffLight计算和rimLight计算的结果都是从0到1，所以我们可以使用这两个值来挑选梯度纹理的不同区域。</p>
<img src="/2015/05/23/Unity_Shaders_and_Effects_Cookbook翻译_第一章/image13.png" alt="image13.png" title="">
<p>A visualization of what is happening inside the Shader code and how it is picking the color to put on the surface<br>上图直观的展示了着色器代码是如何在表面上挑选颜色<br>So the key here is to understand what values we get from the dot product functions as well as how we can manipulate texture. inside of a lighting function. to wrap them around a surface in order to simulate a more complex lighting effect.<br>因此，关键就是去深入理解我们从点击运算获得的结果是如何操纵纹理的，以及在光照函数内部是如何围绕表面来模拟复杂光照效果的。</p>
<p></p><h2>See also<br>参考</h2><br>Refer to Polycount BRDF Map at wiki.polycount.com/BrdfMap<br>可以查看Polycount  wiki上的BRDF贴图<p></p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Shader/"> #Shader </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/23/Unity3D优化系列纹章之《如何在手机场景中渲染成百上千个怪物而不卡》/">
                Unity3D 优化系列纹章之《如何在手机场景中渲染成百上千个怪物而不卡》
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-05-23
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Unity3D/">Unity3D</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/23/Unity3D优化系列纹章之《如何在手机场景中渲染成百上千个怪物而不卡》/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/23/Unity3D优化系列纹章之《如何在手机场景中渲染成百上千个怪物而不卡》/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1>如何在Unity 3D中优化使用大量SkinedMeshRenderer</h1>

<p>Unity3D的核心优化要点就是Combine! 意思就是合并，模型和材质以及贴图最好都要合并。因为一个独立的模型和材质，渲染会占用一次Draw Call，而Draw Call的多少，是现代显卡的瓶颈所在，在手机上尤甚！</p>
<p>比如你有一个怪物，自身的模型和盔甲以及武器分别是独立的模型和贴图，单独渲染这个怪物，就会占用你3个Draw Call。如果你本身的场景就已经占用了大量的Draw Call，还要刷十几个怪物的话，我相信你的游戏在低端手机上是无法跑的流畅的。关于场景制作的优化方式，我会在之后的文章里和大家分享，这里只讨论带骨骼动画的模型如何优化显示。</p>
<p>Unity自身已经替我们做了大量的优化工作，如果你的模型是不带骨骼并且顶点数在300一下，那么重复出现的这个模型是会被自动优化从而只占用一个DrawCall，如下图：<br><img src="/2015/05/23/Unity3D优化系列纹章之《如何在手机场景中渲染成百上千个怪物而不卡》/1-300x193.png" alt="1-300x193.png" title=""></p>
<p>但是如果你需要让这个模型带骨骼并动起来，不好意思，Unity不支持将之优化到一个DrawCall。在下图我们可以看到同时渲染了5个骷髅怪，每个占用3个DrawCall，一共消耗了15个DrawCall：<br><img src="/2015/05/23/Unity3D优化系列纹章之《如何在手机场景中渲染成百上千个怪物而不卡》/2-300x245.png" alt="2-300x245.png" title=""></p>
<p>当然，你可以将这个骷髅怪的模型装备武器合并到一起，纹理也合并掉，公用一个材质，这样五个怪物就只占用5个DrawCall。如果你不需要同时刷新成百上千个怪物的话，这样就够用了。不过有时候我们会希望同时刷更多的怪物出来，可以让玩家感受场面的宏伟，并且打的更爽快。这个时候怎么办呢？</p>
<p>这篇文章介绍的是使用插件优化的方式，插件名称叫做MeshBaker2，下载地址就不提供了，各位可以自行搜索。这是一个非常强大的插件，支持MeshRender和SkinedMeshRender的合并，还支持运行时动态合并，在这里我们使用的就是动态合并的方式，下图可以看到在合并前渲染25个矮人共消耗136个DrawCall：<br><img src="/2015/05/23/Unity3D优化系列纹章之《如何在手机场景中渲染成百上千个怪物而不卡》/3-300x165.png" alt="3-300x165.png" title=""></p>
<p>然后在开启MeshBaker的动态合并之后，我们可以很直接发现DrawCall变成了3个，其中地面和UI各占用一个DrawCall，而我们的25个怪物则已经合并到了一个DrawCall渲染。<br><img src="/2015/05/23/Unity3D优化系列纹章之《如何在手机场景中渲染成百上千个怪物而不卡》/4-300x172.png" alt="4-300x172.png" title=""></p>
<p>其中核心代码如下：<br>//newCombines指这次调用新增加的Render对象，oldCombines指已经不用需要删除的Render对象<br><figure class="highlight c"><figcaption><span>#</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mb.AddDeleteGameObjects (newCombines.ToArray (), oldCombines.ToArray ());</span><br><span class="line">mb.Apply ();</span><br><span class="line">mb.EnableDisableSourceObjectRenderers (<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><br>源代码就不放出了，因为里面的插件涉及到版权问题。只要查看Mesh Baker的官方文档就可以很容易使用了。<br>下面是demo演示地址：<a href="https://db.tt/8C924w6A" target="_blank" rel="external">https://db.tt/8C924w6A</a></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/23/Unity Shaders and Effects Cookbook 翻译 《目录》/">
                Unity Shaders and Effects Cookbook《目录》
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-05-22
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/翻译/">翻译</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/23/Unity Shaders and Effects Cookbook 翻译 《目录》/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/23/Unity Shaders and Effects Cookbook 翻译 《目录》/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1>Preface  1<br>引言 1</h1>

<p></p><h1>Chapter 1: Diffuse Shading  7<br>第一章：漫反射着色器 7</h1><br>Introduction  7<br>介绍 7<br>Creating a basic Surface Shader  8<br>创建一个基础的表面着色器 8<br>Adding properties to a Surface Shader  12<br>添加属性到表面着色器<br>Using properties in a Surface Shader  14<br>在表面着色器中使用属性<br>Creating a custom diffuse lighting model  17<br>创建一个自定义的漫反射光照模型<br>Creating a Half Lambert lighting model  20<br>创建一个Half Lambert[a] 光照模型<br>Creating a ramp texture to control diffuse shading  22<br>使用ramp texture来控制漫反射着色器<br>Creating a faked BRDF using a 2D ramp texture  24<br>通过 2D ramp texture来模拟BRDF[b] <p></p>
<p></p><h1>Chapter 2: Using Textures for Effects  29<br>第二章：使用纹理 29</h1><br>Introduction  29<br>介绍 29<br>Scrolling textures by modifying UV values  30<br>修改UV来滚动纹理 30<br>Animating sprite sheets  33<br>让sprite sheets 运动起来 33<br>Packing and blending textures  39<br>打包和混合纹理 39<br>Normal mapping  44<br>法线贴图 44<br>Creating procedural textures in the Unity editor  48<br>在Unity编辑器里创建procedural textures 48<br>Photoshop levels effect  54<br>实现Photoshop 的效果 54<p></p>
<p></p><h1>Chapter 3: Making Your Game Shine with Specular  59<br>第三章：让你的游戏像镜子那样发光  59</h1><br>Introduction  59<br>介绍 59<br>Utilizing Unity3D’s built-in Specular type  60<br>使用Unity3D自带的镜面反射Shader 60<br>Creating a Phong Specular type  62<br>创建Phong镜面反射类型 62<br>Creating a BlinnPhong Specular type  66<br>创建BlinnPhong镜面反射类型 66<br>Masking Specular with textures  69<br>用纹理来遮罩镜面反射 69<br>Metallic versus soft Specular  74<br>金属类型的镜面反射 74<br>Creating an Anisotropic Specular type  79<br>创建一个各向异性镜面反射类型 79<p></p>
<p></p><h1>Chapter 4:Reflecting Your World 87<br>第四章：反射你的世界 87</h1><br>Creating cubemaps in Unity3D 88<br>在Unity3D里创建一个立方贴图 88<br>Simple Cubemap reflection in Unity3D 93<br>简单的立方贴图反射 93<br>Masking reflections in Unity3D 96<br>Unity3D里的遮罩反射96<br>Normal maps and reflections in Unity3D 100<br>Unity3D 里的法线贴图和反射 100<br>Fresnel reflections in Unity3D 104<br>Unity3D 里的菲涅耳反射[c]<br>Creating a simple dynamic Cubemap system 108<br>创建一个简单的动态立方贴图 108<p></p>
<p></p><h1>Chapter 5:Lighting Models 113<br>第五章：光照模型 113</h1><br>introduction 113<br>介绍 113<br>The Lit sphere lighting model 114<br>被照亮的球体光照模型 114<br>The diffuse convolution lighting model 119<br>漫发射叠加光照模型 119<br>Creating a vehicle paint lighting model 125<br>创建交通工具的绘制光照模型 125<br>Skin shader 130<br>皮肤着色器 130<br>Cloth shading 137<br>布料着色器 137<p></p>
<p></p><h1>Chapter 6: Transparency 143<br>第六章：透明 143</h1><br>introduction 143<br>介绍 143<br>Creating transparency with alpha 143<br>用alpha控制透明度 143<br>Transparent cutoff shader 146<br>透明裁剪着色器 146<br>Depth sorting with render queues 148<br>用渲染对列控制深度排序 148<br>GUI and transparency 151<br>用在Gui上的透明 151<p></p>
<p></p><h1>Chapter 7:Vertex Magic 159<br>第七章：顶点魔法 159</h1><br>introduction 159<br>介绍 159<br>Accessing a vertex color in a Surface Shader 160<br>在表面着色器里访问顶点颜色 160<br>Animating vertices in a Surface Shader 164<br>在表面着色器里运动顶点 164<br>Using vertex color for terrains 168<br>在地形上使用顶点色 168<p></p>
<p></p><h1>Chapter 8: Mobile Shader Adjustment 173<br>第八章：手机着色器调整 173</h1><br>introduction 173<br>介绍 173<br>What is a cheap Shader? 174<br>什么是快速的着色器 174<br>Profiling your Shaders 179<br>分析你的着色器 179<br>Modiflying your shaders for mobile 185<br>为了手机修改你的着色器 185<p></p>
<p></p><h1>Chapter 9: Making Your Shader World Modular with Cglncludes 191<br>第九章：用Cglncludes 让你的着色器世界开发变得更加模块化 191</h1><br>introduction 191<br>介绍 191<br>Cginclude files that are built into Unity 192<br>Unity自带的Cginclude文件 192<br>Creating a cginclude file to store lighting models 195<br>创建一个cginclude文件来保存光照模型 195<br>Building shaders with #define directives 199<br>用#define 指令来建立着色器 199<p></p>
<p></p><h1>Chapter 10:Screen Effects with Unity Render Textures 203<br>第十章：用Unity渲染纹理实现屏幕效果 203</h1><br>Introduction 203<br>介绍 203<br>Setting up the screen effects script system 204<br>设置屏幕效果的脚本系统 204<br>Brightness, saturation, and contrast with screen effects 213<br>用屏幕效果调整亮度、饱和度以及对比度 213<br>Basic Photoshop-like blend modes with screen effects 218<br>像Photoshop那样混合模型和屏幕效果 218<br>The Overlay blend mode with screen effects 224<br>在模型上覆盖屏幕效果 224<p></p>
<p></p><h1>Chapter 11: Gameplay and Screen Effects 229<br>第十一章：游戏性和屏幕效果 229</h1><br>Introduction 229<br>介绍 229<br>Creating an old movie screen effect 230<br>创建一个旧电影屏幕效果 230<br>Creating a night vision screen effect 239<br>创建一个夜视仪效果 239<p></p>
<p></p><h1>Index 249<br>索引249</h1><br>[a]Ivan Zhang:<br>这个算法会加强暗部的亮度<br>[b]Ivan Zhang:<br>BRDF 双向反射分布函数 参见wiki <a href="http://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function" target="_blank" rel="external">http://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function</a><br>[c]Ivan Zhang:<br>参见 Wiki <a href="http://zh.wikipedia.org/wiki/%E8%8F%B2%E6%B6%85%E8%80%B3%E6%96%B9%E7%A8%8B" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E8%8F%B2%E6%B6%85%E8%80%B3%E6%96%B9%E7%A8%8B</a><br>[d]Ivan Zhang:<br>表面着色器<p></p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Shader/"> #Shader </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/20/在Unity3D里用Shader实现遮挡X光效果，类似火炬之光/">
                在Unity3D里用Shader实现遮挡X光效果，类似火炬之光
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-05-20
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Unity3D/">Unity3D</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/20/在Unity3D里用Shader实现遮挡X光效果，类似火炬之光/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/20/在Unity3D里用Shader实现遮挡X光效果，类似火炬之光/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>实现效果：<img src="/2015/05/20/在Unity3D里用Shader实现遮挡X光效果，类似火炬之光/1.png" alt="1.png" title=""><br>原理很简单，就是用两个Pass来渲染物体，第一遍渲染被遮挡部分，开启ZWrite Off Ztest Greater，显示X光效果，第二遍正常渲染未遮挡部分，代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Shader "XRay"</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex ("Base (RGB)", 2D) = "white" &#123;&#125;</span><br><span class="line">        _MatCap ("MatCap (RGB)", 2D) = "white" &#123;&#125;</span><br><span class="line">        _Color("_Color", Color) = (0,1,0,1)</span><br><span class="line">    &#125;</span><br><span class="line">    Subshader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; "Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" &#125;</span><br><span class="line"> </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; "LightMode" = "Vertex" &#125;</span><br><span class="line"> </span><br><span class="line">            Blend One OneMinusSrcColor</span><br><span class="line">            Cull Off</span><br><span class="line">            Lighting Off</span><br><span class="line">            ZWrite Off</span><br><span class="line">            Ztest Greater</span><br><span class="line"> </span><br><span class="line">            CGPROGRAM</span><br><span class="line">                #pragma vertex vert</span><br><span class="line">                #pragma fragment frag</span><br><span class="line">                #pragma fragmentoption ARB_precision_hint_fastest</span><br><span class="line">                #include "UnityCG.cginc"</span><br><span class="line"> </span><br><span class="line">                struct v2f</span><br><span class="line">                &#123;</span><br><span class="line">                    float4 pos    : SV_POSITION;</span><br><span class="line">                    float2 cap    : TEXCOORD0;</span><br><span class="line">                &#125;;</span><br><span class="line"> </span><br><span class="line">                v2f vert (appdata_base v)</span><br><span class="line">                &#123;</span><br><span class="line">                    v2f o;</span><br><span class="line">                    o.pos = mul (UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line"> </span><br><span class="line">                    half2 capCoord;</span><br><span class="line">                    capCoord.x = dot(UNITY_MATRIX_IT_MV[0].xyz,v.normal);</span><br><span class="line">                    capCoord.y = dot(UNITY_MATRIX_IT_MV[1].xyz,v.normal);</span><br><span class="line">                    o.cap = capCoord * 0.5 + 0.5;</span><br><span class="line"> </span><br><span class="line">                    return o;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                uniform float4 _Color;</span><br><span class="line">                uniform sampler2D _MatCap;</span><br><span class="line"> </span><br><span class="line">                float4 frag (v2f i) : COLOR</span><br><span class="line">                &#123;</span><br><span class="line">                    float4 mc = tex2D(_MatCap, i.cap);</span><br><span class="line"> </span><br><span class="line">                    return _Color * mc * 2.0;</span><br><span class="line">                &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; "LightMode" = "Vertex" &#125;</span><br><span class="line">            ColorMaterial AmbientAndDiffuse</span><br><span class="line">            Lighting On</span><br><span class="line">            SetTexture [_MainTex] &#123;</span><br><span class="line">                combine texture</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack "Mobile/VertexLit"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Shader里用到了一张X光贴图，用于优化遮挡部分效果，请直接右键保存<br><img src="/2015/05/20/在Unity3D里用Shader实现遮挡X光效果，类似火炬之光/2.png" alt="2.png" title=""></p>

        
      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Shader/"> #Shader </a>
          
            <a href="/tags/XRay/"> #XRay </a>
          
        </div>
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/05/20/hello-world/">
                Hello World
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-05-19
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Others/">Others</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/20/hello-world/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/20/hello-world/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>原先的Sillyboy.org已经废弃，正在慢慢转移文章过来，此博客后期会不断更新更多原创文章。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  

        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/author.jpg" alt="ivan.z" />
          <p class="site-author-name">ivan.z</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/losetear" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.weibo.com/losetear" target="_blank">Weibo</a>
            </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2013 - 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">ivan.z</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.content img').each(function () {
        var $image = $(this);
        var $imageWrapLink = $image.parent('a');

        if ($imageWrapLink.size() < 1) {
          $imageWrapLink = $image.wrap('<a href="' + this.getAttribute('src') + '"></a>').parent('a');
        }
        $imageWrapLink.addClass('fancybox');
      });
    });
    $('.fancybox').fancybox({
      helpers: {
        overlay: {
          locked: false
        }
      }
    });
  </script>


  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }

  function displaySidebar () {
    setTimeout(function () {
      $('.sidebar-toggle').trigger('click');
    }, 800);
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebarToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.logo-line-before i'), p: { translateX: "100%" }, o: { duration: 500, sequenceQueue: false } },
        { e: $('.logo-line-after i'), p: { translateX: "-100%" }, o: { duration: 500, sequenceQueue: false } },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebarToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  <script type="text/javascript">
    var HEXO_SIDEBAR_CONFIGURATION = 'post';
    $(document).ready(function () {
      if (HEXO_SIDEBAR_CONFIGURATION === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ivanz"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  
  <script type="text/javascript">
    (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
        function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
      e=o.createElement(i);r=o.getElementsByTagName(i)[0];
      e.src='//www.google-analytics.com/analytics.js';
      r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
    ga('create','UA-63181758-1');ga('send','pageview');
  </script>

</body>
</html>
